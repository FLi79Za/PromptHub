<!-- templates/render_prompt.html -->
{% extends "base.html" %}

{% block content %}
<section class="page" style="max-width: 980px; margin: 0 auto;">

  <div class="page-header" style="display:flex; justify-content:space-between; align-items:flex-end; gap:1rem; flex-wrap:wrap;">
    <div>
      <h2 style="margin:0;">Use Prompt</h2>
      <h3 style="margin:0; opacity: 0.6; font-weight: normal;">{{ prompt.title }}</h3>
    </div>

    <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
      <a class="btn-secondary" href="{{ url_for('prompt_history', prompt_id=prompt.id) }}">History</a>
      <a class="btn-secondary" href="{{ url_for('edit_prompt', prompt_id=prompt.id) }}">Edit</a>
      <a class="btn-secondary" href="{{ url_for('index') }}">Back</a>
    </div>
  </div>

  <input type="hidden" id="promptId" value="{{ prompt.id }}">

  {% if variants and variants|length > 1 %}
  <details id="familyPanel" style="background:#1a1a1a; padding:1rem; border-radius:8px; margin:1rem 0 1rem; border:1px solid #333;">
    <summary style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:space-between; gap:1rem; flex-wrap:wrap;">
      <span style="font-weight:bold;">üìé Prompt Family</span>
      <span style="opacity:0.7; font-size:0.9em;">Switch between main + variants</span>
    </summary>

    <div style="margin-top:0.9rem; display:flex; flex-direction:column; gap:0.75rem;">
      <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
        <label style="font-size:0.85em; opacity:0.75; text-transform:uppercase; letter-spacing:0.08em;">Open</label>
        {% for v in variants %}
          <a class="btn-secondary" href="{{ url_for('render_prompt', prompt_id=v.id) }}"
             style="{% if v.id == prompt.id %}outline:2px solid #00bfff;{% endif %}">
            {{ v.title }}
          </a>
        {% endfor %}
      </div>

      <div style="opacity:0.75; font-size:0.9em;">
        Tip: open a different family member to use it, or compare outputs side-by-side.
      </div>
    </div>
  </details>
  {% endif %}

  <form id="useForm" action="{{ url_for('refine_prompt', prompt_id=prompt.id) }}" method="POST">
    <input type="hidden" name="use_render" value="1">
    <input type="hidden" name="override_active" id="overrideActive" value="0">
    <input type="hidden" name="final_override" id="finalOverride" value="">

    {% if prompt.notes %}
    <details id="notesPanel" style="background:#1a1a1a; padding:1.25rem; border-radius:8px; margin:1.25rem 0 1.25rem; border:1px solid #333;">
      <summary style="cursor:pointer; user-select:none; display:flex; align-items:baseline; justify-content:space-between; gap:1rem; flex-wrap:wrap;">
        <h4 style="margin:0;">üóíÔ∏è Notes</h4>
        <div style="opacity:0.7; font-size:0.95em;">Click to toggle</div>
      </summary>

      <div style="margin-top:0.9rem; white-space:pre-wrap; line-height:1.45; opacity:0.92;">{{ prompt.notes }}</div>
    </details>
    {% endif %}

    {% if placeholders_meta %}
    <details id="variablesPanel" style="background:#1a1a1a; padding:1.25rem; border-radius:8px; margin:1.25rem 0 1.25rem; border:1px solid #333;">
      <summary style="cursor:pointer; user-select:none; display:flex; align-items:baseline; justify-content:space-between; gap:1rem; flex-wrap:wrap;">
        <h4 style="margin:0; color:#00bfff;">Variables</h4>
        <div style="opacity:0.7; font-size:0.95em;">Fill placeholders with a descriptor or custom text.</div>
      </summary>

      <div id="placeholderGrid" style="margin-top:1rem; display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:1rem;">
        {% for ph in placeholders_meta %}
        <div class="ph-card" data-ph-index="{{ loop.index0 }}" data-ph-key="{{ ph.key }}" data-ph-display="{{ ph.display }}" style="border:1px solid #333; border-radius:10px; background:#111; padding:0.9rem;">
          <div style="display:flex; align-items:baseline; justify-content:space-between; gap:0.75rem;">
            <div style="font-weight:bold;">{{ ph.display }}</div>
            <div style="display:flex; gap:0.5rem; align-items:center;">
              <label style="font-size:0.85em; opacity:0.75;">Mode</label>
              <select name="ph_mode_{{ loop.index0 }}" class="ph-mode" style="min-width: 140px;">
                <option value="text" selected>Custom</option>
                <option value="descriptor">Descriptor</option>
              </select>
            </div>
          </div>

          <input type="hidden" name="ph_key_{{ loop.index0 }}" value="{{ ph.key }}">

          <div class="ph-descriptor" style="margin-top:0.75rem; display:none;">
            <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; justify-content:space-between;">
              <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
                <label style="font-size:0.85em; opacity:0.75;">Pack</label>
                <select name="ph_pack_{{ loop.index0 }}" class="ph-pack" style="min-width: 180px;">
                  <option value="all">(All packs)</option>
                </select>
              </div>

              <button type="button" class="btn-secondary ph-clear" title="Clear this placeholder">Clear</button>
            </div>

            <div style="margin-top:0.5rem; display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
              <input type="text" class="ph-search" placeholder="Search descriptors‚Ä¶" style="flex:1; min-width:200px;">
              <button type="button" class="btn-secondary ph-search-btn">Search</button>
            </div>

            <div class="ph-results" style="margin-top:0.6rem; border:1px solid #333; border-radius:8px; max-height:220px; overflow:auto; background:#0e0e0e; padding:0.35rem;">
              <div style="opacity:0.7; padding:0.6rem;">Search to load descriptors‚Ä¶</div>
            </div>

            <input type="hidden" name="ph_desc_text_{{ loop.index0 }}" class="ph-desc-text" value="">
          </div>

          <div class="ph-text" style="margin-top:0.75rem; display:block;">
            <input type="text" name="ph_text_{{ loop.index0 }}" class="ph-text-input" placeholder="Type a value‚Ä¶" style="width:100%;">
          </div>

          <div style="margin-top:0.7rem;">
            <div style="font-size:0.8em; opacity:0.7; text-transform:uppercase; letter-spacing:0.08em;">Selected text</div>
            <div class="ph-preview" style="margin-top:0.35rem; white-space:pre-wrap; line-height:1.35; opacity:0.92;"></div>
          </div>
        </div>
        {% endfor %}
      </div>
    </details>
    {% endif %}

    <details id="descriptorPanel" style="background:#1a1a1a; padding:1rem; border-radius:8px; margin-bottom:1rem; border:1px solid #333;">
      <summary style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:space-between; gap:1rem;">
        <span style="font-weight:bold;">üß© Insert Descriptors</span>
        <span style="opacity:0.7; font-size:0.9em;">Click to toggle</span>
      </summary>

      <div style="margin-top:1rem; display:flex; flex-direction:column; gap:0.75rem;">
        <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; justify-content:space-between;">
          <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
            <span style="font-size:0.85em; opacity:0.7; text-transform:uppercase; letter-spacing:0.08em;">Scope</span>

            <div style="display:flex; gap:0.5rem; align-items:center;">
              <button type="button" class="btn-secondary" id="scopeRelevantBtn" onclick="setDescriptorScope('relevant')" title="Show quick filters (does not hide types)">
                Relevant only
              </button>
              <button type="button" class="btn-secondary" id="scopeAllBtn" onclick="setDescriptorScope('all')" title="Show all types">
                All
              </button>
            </div>

            <span id="descriptorScopeHint" style="font-size:0.9em; opacity:0.7;"></span>
          </div>

          <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
            <label style="margin:0; font-size:0.85em; opacity:0.7; text-transform:uppercase; letter-spacing:0.08em;">Pack</label>
            <select id="descriptorPackSelect" onchange="refreshDescriptors()" style="min-width: 200px;">
              <option value="all">(All packs)</option>
            </select>
          </div>
        </div>

        <div id="relevantChips" style="display:flex; gap:0.5rem; flex-wrap:wrap;"></div>

        <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
          <input type="text" id="descriptorSearch" placeholder="Search descriptors..." oninput="debouncedRefreshDescriptors()" style="flex:1; min-width:240px;">
          <button type="button" class="btn-secondary" onclick="refreshDescriptors(true)">Search</button>
          <span id="descriptorStatus" style="font-size:0.9em; opacity:0.7;"></span>
        </div>

        <div id="descriptorResults"
             style="border:1px solid #333; border-radius:8px; max-height:320px; overflow:auto; background:#111; padding:0.5rem;">
          <div style="opacity:0.7; padding:0.75rem;">Loading descriptors‚Ä¶</div>
        </div>

        <div style="font-size:0.9em; opacity:0.75;">
          Clicking a descriptor inserts rendered text into the editor. Tokens remain available in this panel for advanced workflows.
        </div>
      </div>
    </details>

    <div style="display:grid; grid-template-columns: 1fr; gap:0.5rem; margin: 1rem 0 1rem;">
      <label>Template Preview (shows where placeholders appear)</label>
      <textarea id="templatePreview" readonly style="width:100%; min-height:140px; resize:vertical; padding:0.75rem; border-radius:8px; border:1px solid #333; background:#0e0e0e; color:#e6e6e6; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace; font-size:0.92em; line-height:1.35;">{{ base_text }}</textarea>
    </div>

    <textarea id="templateSource" style="display:none;">{{ prompt.content }}</textarea>

    <div style="display:grid; grid-template-columns: 1fr; gap:0.5rem; margin-bottom: 1rem;">
      <label for="finalOutput">Final Prompt (editable)</label>

      <textarea name="content" id="finalOutput" rows="12" style="font-family:monospace; line-height:1.5; font-size:1.1em; padding:1rem;">{{ final_text or prompt.content }}</textarea>

      <div style="display:flex; gap:0.75rem; flex-wrap:wrap; align-items:center; justify-content:space-between;">
        <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
          <button type="button" class="btn-secondary" id="btnCopyFinal">Copy</button>
          <button type="button" class="btn-secondary" id="btnResetFinal">Reset</button>
        </div>

        {% if ollama_models %}
        <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
          <select name="model" style="min-width: 220px;">
            {% for m in ollama_models %}
              <option value="{{ m }}" {% if session.get('ollama_model') == m %}selected{% endif %}>{{ m }}</option>
            {% endfor %}
          </select>
          <input type="text" name="instruction" placeholder="Refine instruction (optional)" style="min-width: 240px;">
          <input type="hidden" name="mode" value="refine">
          <button type="submit" class="btn-secondary" title="Send current output to Ollama refinement">‚ú® Refine with Ollama</button>
        </div>
        {% endif %}
      </div>

      <details id="findReplacePanel" style="background:#1a1a1a; padding:1rem; border-radius:8px; border:1px solid #333; margin-top:0.75rem;">
        <summary style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:space-between; gap:1rem; flex-wrap:wrap;">
          <span style="font-weight:bold;">üîé Find & Replace</span>
          <span style="opacity:0.7; font-size:0.9em;">Works on the Final Prompt text</span>
        </summary>

        <div style="margin-top:0.9rem; display:flex; flex-direction:column; gap:0.75rem;">
          <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
            <input id="frFind" type="text" placeholder="Find‚Ä¶" style="flex:1; min-width:220px;">
            <input id="frReplace" type="text" placeholder="Replace with‚Ä¶" style="flex:1; min-width:220px;">
          </div>

          <div style="display:flex; gap:0.75rem; flex-wrap:wrap; align-items:center; justify-content:space-between;">
            <div style="display:flex; gap:0.75rem; flex-wrap:wrap; align-items:center;">
              <label style="display:flex; gap:0.35rem; align-items:center; opacity:0.85;">
                <input id="frMatchCase" type="checkbox"> Match case
              </label>
              <label style="display:flex; gap:0.35rem; align-items:center; opacity:0.85;">
                <input id="frWholeWord" type="checkbox"> Whole word
              </label>
              <span id="frStatus" style="font-size:0.9em; opacity:0.7;"></span>
            </div>

            <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
              <button type="button" class="btn-secondary" onclick="frFindNext()">Find next</button>
              <button type="button" class="btn-secondary" onclick="frReplaceOne()">Replace</button>
              <button type="button" class="btn-secondary" onclick="frReplaceAll()">Replace all</button>
              <span id="replaceFeedback" style="opacity:0; transition:opacity .2s; font-size:0.9em;">‚úÖ</span>
            </div>
          </div>
        </div>
      </details>

    </div>

  </form>

</section>

<script>
/*
  Client-side placeholder UX:

  - Placeholders are [[NAME]] in the template.
  - Descriptor tokens are Descriptor ID in stored prompt content.
  - On this page, users can pick descriptors or custom text per placeholder.
  - We keep "Final Prompt" editable and only overwrite it from preview if user hasn't manually edited.
*/

let _descriptorTypes = [];
let _descriptorScope = "all"; // "all" | "relevant"
let _userEditedFinal = false;

function setUserEditedFinal(v) {
  _userEditedFinal = !!v;
  const overrideActive = document.getElementById("overrideActive");
  if (overrideActive) overrideActive.value = _userEditedFinal ? "1" : "0";
}

function syncFinalOverride() {
  const ta = document.getElementById("finalOutput");
  const hidden = document.getElementById("finalOverride");
  if (ta && hidden) hidden.value = ta.value || "";
}

function normalizePackName(s) {
  return String(s || "").trim();
}

async function loadDescriptorTypes() {
  try {
    const res = await fetch("/api/descriptors/types", { headers: { "Accept": "application/json" } });
    if (!res.ok) throw new Error("types");
    const data = await res.json();
    return Array.isArray(data) ? data : [];
  } catch (e) {
    return [];
  }
}

function populatePackDropdown() {
  const sel = document.getElementById("descriptorPackSelect");
  if (!sel) return;

  const current = sel.value || "all";
  while (sel.options.length > 1) sel.remove(1);

  _descriptorTypes.forEach(t => {
    const opt = document.createElement("option");
    opt.value = t;
    opt.textContent = t;
    sel.appendChild(opt);
  });

  const want = _descriptorTypes.includes(current) ? current : "all";
  sel.value = want;
}

function setDescriptorStatus(msg) {
  const el = document.getElementById("descriptorStatus");
  if (el) el.textContent = msg || "";
}

function setDescriptorScope(scope) {
  _descriptorScope = (scope === "relevant") ? "relevant" : "all";

  const b1 = document.getElementById("scopeRelevantBtn");
  const b2 = document.getElementById("scopeAllBtn");
  const hint = document.getElementById("descriptorScopeHint");

  if (b1) b1.style.outline = (_descriptorScope === "relevant") ? "2px solid #00bfff" : "none";
  if (b2) b2.style.outline = (_descriptorScope === "all") ? "2px solid #00bfff" : "none";
  if (hint) hint.textContent = (_descriptorScope === "relevant") ? "Quick filters enabled" : "";

  renderRelevantChips();
  refreshDescriptors();
}

function getRelevantTypesFromTemplate() {
  const template = document.getElementById("templateSource")?.value || "";
  const placeholders = Array.from(new Set((template.match(/\[\[([^\]]+)\]\]/g) || []).map(m => m.slice(2, -2).trim().toLowerCase())));

  const hits = new Set();
  const typesLower = _descriptorTypes.map(t => String(t).toLowerCase());

  placeholders.forEach(ph => {
    typesLower.forEach((t, idx) => {
      if (ph === t || ph.includes(t) || t.includes(ph)) hits.add(_descriptorTypes[idx]);
    });
  });

  const fallback = ["style", "mood", "lighting", "camera", "lens", "environment", "character", "subject", "composition", "colour", "color"];
  fallback.forEach(f => {
    const idx = typesLower.indexOf(f);
    if (idx !== -1) hits.add(_descriptorTypes[idx]);
  });

  return Array.from(hits);
}

function renderRelevantChips() {
  const wrap = document.getElementById("relevantChips");
  if (!wrap) return;

  wrap.innerHTML = "";
  if (_descriptorScope !== "relevant") return;

  const relevant = getRelevantTypesFromTemplate();
  if (!relevant.length) {
    wrap.innerHTML = "<div style=\"opacity:0.7;\">No relevant types detected. Use search or switch to All.</div>";
    return;
  }

  relevant.forEach(t => {
    const chip = document.createElement("button");
    chip.type = "button";
    chip.className = "btn-secondary";
    chip.textContent = t;
    chip.style.padding = "0.35rem 0.6rem";
    chip.style.borderRadius = "999px";
    chip.onclick = () => {
      const sel = document.getElementById("descriptorPackSelect");
      if (sel) sel.value = t;
      refreshDescriptors(true);
    };
    wrap.appendChild(chip);
  });
}

function buildDescriptorListUrl() {
  const q = (document.getElementById("descriptorSearch")?.value || "").trim();
  const packSel = (document.getElementById("descriptorPackSelect")?.value || "all").trim();

  const params = new URLSearchParams();
  if (q) params.set("q", q);
  if (packSel && packSel !== "all") params.set("type", packSel);

  const base = "/api/descriptors/list";
  const qs = params.toString();
  return qs ? (base + "?" + qs) : base;
}

function getPlaceholderCards() {
  return Array.from(document.querySelectorAll(".ph-card"));
}

function setCardPreview(card, text) {
  const prev = card.querySelector(".ph-preview");
  if (prev) prev.textContent = text || "";
}

function setCardSelectedDescriptorText(card, text) {
  const hidden = card.querySelector(".ph-desc-text");
  if (hidden) hidden.value = text || "";
  setCardPreview(card, text || "");
}

function getModeForCard(card) {
  const sel = card.querySelector(".ph-mode");
  return sel ? String(sel.value || "text") : "text";
}

function getPlaceholderDisplay(card) {
  return card.getAttribute("data-ph-display") || "";
}

function getTextValue(card) {
  const inp = card.querySelector(".ph-text-input");
  return inp ? String(inp.value || "") : "";
}

function getDescriptorText(card) {
  const hidden = card.querySelector(".ph-desc-text");
  return hidden ? String(hidden.value || "") : "";
}

function applyPlaceholderToTemplate(template, display, replacement) {
  const token = "[[" + display + "]]";
  return template.split(token).join(replacement || "");
}

function clientPreviewFinal(force) {
  const template = document.getElementById("templateSource")?.value || "";
  let out = template;

  getPlaceholderCards().forEach(card => {
    const disp = getPlaceholderDisplay(card);
    if (!disp) return;

    const mode = getModeForCard(card);
    const rep = (mode === "descriptor") ? getDescriptorText(card) : getTextValue(card);
    out = applyPlaceholderToTemplate(out, disp, rep);
  });

  if (!_userEditedFinal || force) {
    const ta = document.getElementById("finalOutput");
    if (ta) ta.value = out;
    syncFinalOverride();
  }
}

async function loadDescriptorTypesOnce() {
  if (_descriptorTypes.length) return;
  _descriptorTypes = await loadDescriptorTypes();
}

function populateAllPlaceholderPackSelects(types) {
  getPlaceholderCards().forEach(card => {
    const sel = card.querySelector(".ph-pack");
    if (!sel) return;

    const current = sel.value || "all";
    while (sel.options.length > 1) sel.remove(1);

    types.forEach(t => {
      const opt = document.createElement("option");
      opt.value = t;
      opt.textContent = t;
      sel.appendChild(opt);
    });

    sel.value = (types.includes(current)) ? current : "all";
  });
}

function attachPlaceholderHandlers() {
  document.addEventListener("change", function (ev) {
    const target = ev.target;
    if (!target) return;

    if (target.classList.contains("ph-mode")) {
      const card = target.closest(".ph-card");
      if (!card) return;

      const mode = String(target.value || "text");
      const d = card.querySelector(".ph-descriptor");
      const t = card.querySelector(".ph-text");

      if (d) d.style.display = (mode === "descriptor") ? "block" : "none";
      if (t) t.style.display = (mode === "text") ? "block" : "none";

      if (mode === "descriptor") setCardPreview(card, getDescriptorText(card));
      else setCardPreview(card, getTextValue(card));

      clientPreviewFinal();
      return;
    }

    if (target.classList.contains("ph-pack")) {
      const card = target.closest(".ph-card");
      if (!card) return;

      const results = card.querySelector(".ph-results");
      if (results) results.innerHTML = "<div style=\"opacity:0.7; padding:0.6rem;\">Search to load descriptors‚Ä¶</div>";
      return;
    }
  });

  document.addEventListener("input", function (ev) {
    const target = ev.target;
    if (!target) return;

    if (target.classList.contains("ph-text-input")) {
      const card = target.closest(".ph-card");
      if (!card) return;
      setCardPreview(card, String(target.value || ""));
      clientPreviewFinal();
      return;
    }
  });

  document.addEventListener("click", async function (ev) {
    const target = ev.target;
    if (!target) return;

    if (target.classList.contains("ph-search-btn")) {
      const card = target.closest(".ph-card");
      if (!card) return;
      await placeholderSearch(card);
      return;
    }

    if (target.classList.contains("ph-clear")) {
      const card = target.closest(".ph-card");
      if (!card) return;
      clearPlaceholder(card);
      clientPreviewFinal();
      return;
    }
  });
}

function clearPlaceholder(card) {
  const txt = card.querySelector(".ph-text-input");
  if (txt) txt.value = "";
  const hidden = card.querySelector(".ph-desc-text");
  if (hidden) hidden.value = "";

  setCardPreview(card, "");
  const res = card.querySelector(".ph-results");
  if (res) res.innerHTML = "<div style=\"opacity:0.7; padding:0.6rem;\">Search to load descriptors‚Ä¶</div>";
}

async function placeholderSearch(card) {
  const qEl = card.querySelector(".ph-search");
  const q = qEl ? String(qEl.value || "").trim() : "";
  const packEl = card.querySelector(".ph-pack");
  const pack = packEl ? String(packEl.value || "all").trim() : "all";
  const box = card.querySelector(".ph-results");

  if (!box) return;
  if (!q) {
    box.innerHTML = "<div style=\"opacity:0.7; padding:0.6rem;\">Type something to search.</div>";
    return;
  }

  try {
    const params = new URLSearchParams();
    params.set("q", q);
    if (pack && pack !== "all") params.set("type", pack);

    const url = "/api/descriptors/list?" + params.toString();
    const items = await fetchDescriptors(url);
    renderPlaceholderResults(card, Array.isArray(items) ? items : []);
  } catch (e) {
    box.innerHTML = "<div style=\"opacity:0.85; padding:0.6rem;\">Failed to load descriptors.</div>";
  }
}

function renderPlaceholderResults(card, items) {
  const box = card.querySelector(".ph-results");
  if (!box) return;

  if (!items.length) {
    box.innerHTML = "<div style=\"opacity:0.7; padding:0.6rem;\">No results.</div>";
    return;
  }

  box.innerHTML = "";

  items.forEach(d => {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.gap = "0.5rem";
    row.style.alignItems = "center";
    row.style.justifyContent = "space-between";
    row.style.borderBottom = "1px solid #222";
    row.style.padding = "0.45rem 0.5rem";

    const left = document.createElement("div");
    left.style.flex = "1";
    left.style.minWidth = "0";

    const title = document.createElement("div");
    title.textContent = d.name || d.id || "descriptor";
    title.style.fontWeight = "bold";
    title.style.whiteSpace = "nowrap";
    title.style.overflow = "hidden";
    title.style.textOverflow = "ellipsis";

    const meta = document.createElement("div");
    meta.textContent = (d.type ? (d.type + " ‚Ä¢ ") : "") + (d.pack || "");
    meta.style.opacity = "0.7";
    meta.style.fontSize = "0.85em";
    meta.style.whiteSpace = "nowrap";
    meta.style.overflow = "hidden";
    meta.style.textOverflow = "ellipsis";

    left.appendChild(title);
    left.appendChild(meta);

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "btn-secondary";
    btn.textContent = "Use";
    btn.onclick = () => {
      const txt = d.rendered_text || d.text || (d.name || "");
      setCardSelectedDescriptorText(card, txt || "");
      clientPreviewFinal();
    };

    row.appendChild(left);
    row.appendChild(btn);

    box.appendChild(row);
  });
}

function attachFinalEditorHandlers() {
  const ta = document.getElementById("finalOutput");
  if (!ta) return;

  ta.addEventListener("input", function () {
    setUserEditedFinal(true);
    syncFinalOverride();
  });

  const btnCopy = document.getElementById("btnCopyFinal");
  if (btnCopy) {
    btnCopy.addEventListener("click", async function () {
      try {
        await navigator.clipboard.writeText(ta.value || "");
        btnCopy.textContent = "Copied!";
        setTimeout(() => { btnCopy.textContent = "Copy"; }, 800);
      } catch (e) {
        ta.select();
        document.execCommand("copy");
      }
    });
  }

  const btnReset = document.getElementById("btnResetFinal");
  if (btnReset) {
    btnReset.addEventListener("click", function () {
      setUserEditedFinal(false);
      clientPreviewFinal(true);
    });
  }
}

function insertTextAtCursor(text) {
  const ta = document.getElementById("finalOutput");
  if (!ta) return;

  const s = ta.selectionStart || 0;
  const e = ta.selectionEnd || 0;
  const before = ta.value.slice(0, s);
  const after = ta.value.slice(e);

  ta.value = before + text + after;

  const newPos = s + text.length;
  ta.focus();
  ta.setSelectionRange(newPos, newPos);

  setUserEditedFinal(true);
  syncFinalOverride();
}

function insertDescriptorToken(id) {
  const open = String.fromCharCode(123, 123);
  const close = String.fromCharCode(125, 125);
  insertTextAtCursor(open + "descriptor:" + id + close);
}

function insertDescriptorText(text) {
  insertTextAtCursor(text || "");
}

function renderDescriptorResults(items) {
  const box = document.getElementById("descriptorResults");
  if (!box) return;

  if (!items.length) {
    box.innerHTML = "<div style=\"opacity:0.7; padding:0.75rem;\">No results.</div>";
    return;
  }

  box.innerHTML = "";

  items.forEach(d => {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.gap = "0.5rem";
    row.style.alignItems = "center";
    row.style.justifyContent = "space-between";
    row.style.borderBottom = "1px solid #222";
    row.style.padding = "0.55rem 0.6rem";

    const left = document.createElement("div");
    left.style.flex = "1";
    left.style.minWidth = "0";

    const title = document.createElement("div");
    title.textContent = d.name || d.id || "descriptor";
    title.style.fontWeight = "bold";
    title.style.whiteSpace = "nowrap";
    title.style.overflow = "hidden";
    title.style.textOverflow = "ellipsis";

    const meta = document.createElement("div");
    meta.textContent = (d.type ? (d.type + " ‚Ä¢ ") : "") + (d.pack || "");
    meta.style.opacity = "0.7";
    meta.style.fontSize = "0.85em";
    meta.style.whiteSpace = "nowrap";
    meta.style.overflow = "hidden";
    meta.style.textOverflow = "ellipsis";

    left.appendChild(title);
    left.appendChild(meta);

    const actions = document.createElement("div");
    actions.style.display = "flex";
    actions.style.gap = "0.5rem";
    actions.style.flexWrap = "wrap";
    actions.style.alignItems = "center";

    const btnText = document.createElement("button");
    btnText.type = "button";
    btnText.className = "btn-secondary";
    btnText.textContent = "Insert text";
    btnText.onclick = (e) => { e.stopPropagation(); insertDescriptorText(d.rendered_text || d.text || d.name || ""); };

    const btnToken = document.createElement("button");
    btnToken.type = "button";
    btnToken.className = "btn-secondary";
    btnToken.textContent = "Insert token";
    btnToken.onclick = (e) => { e.stopPropagation(); insertDescriptorToken(d.id); };

    actions.appendChild(btnText);
    actions.appendChild(btnToken);
    row.appendChild(actions);

    box.appendChild(row);
  });
}

async function fetchDescriptors(url) {
  const res = await fetch(url, { method: "GET", headers: { "Accept": "application/json" } });
  if (!res.ok) throw new Error("list");
  return await res.json();
}

async function refreshDescriptors() {
  const q = (document.getElementById("descriptorSearch")?.value || "").trim();
  const packSel = (document.getElementById("descriptorPackSelect")?.value || "all").trim();

  setDescriptorStatus("Loading‚Ä¶");

  try {
    const url = buildDescriptorListUrl();
    const data = await fetchDescriptors(url);
    const items = Array.isArray(data) ? data : [];

    if (packSel !== "all" && _descriptorTypes.length) {
      const lower = new Set(_descriptorTypes.map(t => String(t).toLowerCase()));
      if (!lower.has(packSel.toLowerCase())) {
        const sel = document.getElementById("descriptorPackSelect");
        if (sel) sel.value = "all";
      }
    }

    setDescriptorStatus(items.length ? (items.length + " found") : (q ? "No results" : "No descriptors"));
    renderDescriptorResults(items);
  } catch (e) {
    setDescriptorStatus("Failed to load");
    const box = document.getElementById("descriptorResults");
    if (box) {
      box.innerHTML = "<div style=\"opacity:0.8; padding:0.75rem;\">Could not load descriptors. Check that <code>/api/descriptors/list</code> is available.</div>";
    }
  }
}

let _descTimer = null;
function debouncedRefreshDescriptors() {
  clearTimeout(_descTimer);
  _descTimer = setTimeout(() => refreshDescriptors(), 250);
}

(async function initUsePrompt() {
  const types = await loadDescriptorTypes();
  populateAllPlaceholderPackSelects(types);
  attachPlaceholderHandlers();

  attachFinalEditorHandlers();

  getPlaceholderCards().forEach(card => setCardPreview(card, ""));
  clientPreviewFinal();

  await loadDescriptorTypesOnce();
  populatePackDropdown();
  setDescriptorScope("all");
  renderRelevantChips();
  refreshDescriptors();
})();

(function () {
  function applyModeForCard(card) {
    if (!card) return;

    const modeEl = card.querySelector(".ph-mode");
    const mode = modeEl ? String(modeEl.value || "text") : "text";

    const d = card.querySelector(".ph-descriptor");
    const t = card.querySelector(".ph-text");

    if (d) d.style.display = (mode === "descriptor") ? "block" : "none";
    if (t) t.style.display = (mode === "text") ? "block" : "none";
  }

  document.querySelectorAll(".ph-card").forEach(applyModeForCard);

  document.addEventListener("change", function (ev) {
    const sel = ev.target && ev.target.closest ? ev.target.closest(".ph-mode") : null;
    if (!sel) return;

    const card = sel.closest(".ph-card");
    applyModeForCard(card);

    try {
      if (typeof clientPreviewFinal === "function") clientPreviewFinal();
    } catch (e) {}
  });
})();

(function () {
  const templateBox = document.getElementById("templatePreview");
  if (!templateBox) return;

  function selectNextOccurrence(token) {
    const hay = templateBox.value || "";
    if (!hay || !token) return;

    const startFrom = (templateBox.selectionEnd || 0);
    let idx = hay.indexOf(token, startFrom);
    if (idx === -1) idx = hay.indexOf(token, 0);
    if (idx === -1) return;

    templateBox.focus();
    templateBox.setSelectionRange(idx, idx + token.length);

    const before = hay.slice(0, idx);
    const line = before.split("\n").length - 1;
    const approxLineHeight = 18;
    templateBox.scrollTop = Math.max(0, (line - 2) * approxLineHeight);
  }

  document.addEventListener("click", function (ev) {
    const t = ev.target;

    if (t && t.closest && t.closest("input, select, textarea, button, a, .ph-results")) {
      return;
    }

    const card = t && t.closest ? t.closest(".ph-card") : null;
    if (!card) return;

    const disp = card.getAttribute("data-ph-display") || "";
    if (!disp) return;

    const token = "[[" + disp + "]]";
    selectNextOccurrence(token);
  });
})();

// =========================
// Find & Replace (Final Prompt textarea)
// =========================
let frLastNeedle = "";
let frLastIndex = 0;

function frGetTextArea() {
  return document.getElementById("finalOutput");
}

function frEscapeRegExp(s) {
  return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function frBuildNeedleRegex(needle, wholeWord, matchCase) {
  const safe = frEscapeRegExp(needle);
  const body = wholeWord ? "\\b" + safe + "\\b" : safe;
  const flags = matchCase ? "g" : "gi";
  return new RegExp(body, flags);
}

function frShowStatus(msg) {
  const el = document.getElementById("frStatus");
  if (el) el.textContent = msg || "";
}

function frFlashReplaced() {
  const el = document.getElementById("replaceFeedback");
  if (!el) return;
  el.style.opacity = "1";
  setTimeout(() => { el.style.opacity = "0"; }, 700);
}

function frFindNext() {
  const ta = frGetTextArea();
  const findEl = document.getElementById("frFind");
  const matchCaseEl = document.getElementById("frMatchCase");
  const wholeWordEl = document.getElementById("frWholeWord");

  if (!ta || !findEl) return;
  const needle = String(findEl.value || "");
  if (!needle) {
    frShowStatus("Type something to find.");
    return;
  }

  const matchCase = !!(matchCaseEl && matchCaseEl.checked);
  const wholeWord = !!(wholeWordEl && wholeWordEl.checked);

  const text = String(ta.value || "");
  const rx = frBuildNeedleRegex(needle, wholeWord, matchCase);

  const startFrom = (needle === frLastNeedle) ? (ta.selectionEnd || frLastIndex || 0) : 0;
  frLastNeedle = needle;
  frLastIndex = startFrom;

  rx.lastIndex = startFrom;
  let m = rx.exec(text);
  if (!m) {
    rx.lastIndex = 0;
    m = rx.exec(text);
  }

  if (!m) {
    frShowStatus("No matches.");
    return;
  }

  const start = m.index;
  const end = start + m[0].length;

  ta.focus();
  ta.setSelectionRange(start, end);
  frLastIndex = end;
  frShowStatus("Match selected.");
}

function frReplaceOne() {
  const ta = frGetTextArea();
  const findEl = document.getElementById("frFind");
  const replEl = document.getElementById("frReplace");
  const matchCaseEl = document.getElementById("frMatchCase");
  const wholeWordEl = document.getElementById("frWholeWord");

  if (!ta || !findEl || !replEl) return;
  const needle = String(findEl.value || "");
  const replacement = String(replEl.value || "");

  if (!needle) {
    frShowStatus("Type something to find.");
    return;
  }

  const matchCase = !!(matchCaseEl && matchCaseEl.checked);
  const wholeWord = !!(wholeWordEl && wholeWordEl.checked);

  const selStart = ta.selectionStart || 0;
  const selEnd = ta.selectionEnd || 0;
  const selected = String(ta.value || "").slice(selStart, selEnd);

  const rx = frBuildNeedleRegex(needle, wholeWord, matchCase);
  const selectedMatches = !!(selected && rx.test(selected));

  if (!selected || !selectedMatches) {
    frFindNext();
  }

  const s = ta.selectionStart || 0;
  const e = ta.selectionEnd || 0;
  const nowSelected = String(ta.value || "").slice(s, e);

  if (!nowSelected) {
    frShowStatus("No match selected.");
    return;
  }

  const text = String(ta.value || "");
  ta.value = text.slice(0, s) + replacement + text.slice(e);
  const newPos = s + replacement.length;
  ta.focus();
  ta.setSelectionRange(newPos, newPos);
  frLastIndex = newPos;
  frFlashReplaced();
  frShowStatus("Replaced one.");

  if (typeof setUserEditedFinal === "function") setUserEditedFinal(true);
  if (typeof syncFinalOverride === "function") syncFinalOverride();
}

function frReplaceAll() {
  const ta = frGetTextArea();
  const findEl = document.getElementById("frFind");
  const replEl = document.getElementById("frReplace");
  const matchCaseEl = document.getElementById("frMatchCase");
  const wholeWordEl = document.getElementById("frWholeWord");

  if (!ta || !findEl || !replEl) return;
  const needle = String(findEl.value || "");
  const replacement = String(replEl.value || "");

  if (!needle) {
    frShowStatus("Type something to find.");
    return;
  }

  const matchCase = !!(matchCaseEl && matchCaseEl.checked);
  const wholeWord = !!(wholeWordEl && wholeWordEl.checked);

  const text = String(ta.value || "");
  const rx = frBuildNeedleRegex(needle, wholeWord, matchCase);

  let count = 0;
  const out = text.replace(rx, () => {
    count += 1;
    return replacement;
  });

  ta.value = out;
  ta.focus();
  ta.setSelectionRange(0, 0);
  frLastNeedle = needle;
  frLastIndex = 0;

  frFlashReplaced();
  frShowStatus(count ? ("Replaced " + count + ".") : "No matches.");

  if (typeof setUserEditedFinal === "function") setUserEditedFinal(true);
  if (typeof syncFinalOverride === "function") syncFinalOverride();
}

</script>

{% endblock %}
