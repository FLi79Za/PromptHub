{% extends "base.html" %}

{% block content %}
<section class="page" style="max-width: 800px; margin: 0 auto;">

  <div class="page-header" style="margin-bottom: 1rem;">
    <div>
      <h2 style="margin:0;">Use Prompt</h2>
      <h3 style="margin:0; opacity: 0.6; font-weight: normal;">{{ prompt.title }}</h3>
    </div>
    <a class="btn-secondary" href="{{ url_for('index') }}">Back to Library</a>
  </div>

  {% if variants and variants|length > 1 %}
  <div style="margin-bottom: 2rem; background: #111; padding: 0.75rem; border-radius: 8px; border: 1px solid #333; display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
    <span style="font-size:0.85em; text-transform:uppercase; color:#666; font-weight:bold; margin-right:0.5rem;">Variants:</span>

    {% for v in variants %}
      <a href="{{ url_for('render_prompt', prompt_id=v.id) }}"
         style="text-decoration:none; padding: 0.3rem 0.8rem; border-radius: 4px; font-size: 0.9em; transition: all 0.2s;
                {% if v.id == prompt.id %}
                  background: #00bfff; color: #000; font-weight: bold; cursor: default;
                {% else %}
                  background: #333; color: #ccc;
                {% endif %}">
        {{ v.title }}
      </a>
    {% endfor %}
  </div>
  {% endif %}

  {% if prompt.notes %}
  <details style="background: #252525; border-left: 4px solid #00bfff; border-radius: 4px; margin-bottom: 2rem;">
    <summary style="padding: 0.75rem 1rem; cursor: pointer; color: #fff; font-weight: bold; font-size: 0.95em; user-select: none;">
      üìù Notes & Instructions (Click to toggle)
    </summary>
    <div style="padding: 0 1rem 1rem 1rem; color: #ddd; font-size: 0.95em; white-space: pre-wrap; line-height: 1.5; border-top: 1px solid #333; margin-top: 0.25rem; padding-top: 0.75rem;">{{ prompt.notes }}</div>
  </details>
  {% endif %}

  {% if placeholders %}
  <div style="background:#1a1a1a; padding:1.5rem; border-radius:8px; margin-bottom:2rem; border:1px solid #333;">
    <h4 style="margin-top:0; color:#00bfff; margin-bottom:1rem;">Variables</h4>
    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:1rem;">
      {% for name in placeholders %}
      <div>
        <label style="font-size:0.85em; text-transform:uppercase; letter-spacing:1px; opacity:0.7;">{{ name }}</label>
        <input type="text" class="placeholder-input" data-target="{{ name }}" oninput="updateFinal()" placeholder="Value for {{ name }}..." style="width:100%;">
      </div>
      {% endfor %}
    </div>
  </div>
  {% endif %}

  <!-- Descriptor picker (Use-stage only) -->
  <details id="descriptorPanel" style="background:#1a1a1a; padding:1rem; border-radius:8px; margin-bottom:1rem; border:1px solid #333;">
    <summary style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:space-between; gap:1rem;">
      <span style="font-weight:bold;">üß© Insert Descriptors</span>
      <span style="opacity:0.7; font-size:0.9em;">Click to toggle</span>
    </summary>

    <div style="margin-top:1rem; display:flex; flex-direction:column; gap:0.75rem;">
      <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; justify-content:space-between;">
        <!-- Scope toggle -->
        <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
          <span style="font-size:0.85em; opacity:0.7; text-transform:uppercase; letter-spacing:0.08em;">Scope</span>

          <div style="display:flex; gap:0.5rem; align-items:center;">
            <button type="button" class="btn-secondary" id="scopeRelevantBtn" onclick="setDescriptorScope('relevant')" title="Show relevant packs for this prompt type">
              Relevant only
            </button>
            <button type="button" class="btn-secondary" id="scopeAllBtn" onclick="setDescriptorScope('all')" title="Show all descriptor packs">
              All
            </button>
          </div>

          <span id="descriptorScopeHint" style="font-size:0.9em; opacity:0.7;"></span>
        </div>

        <!-- Pack type dropdown -->
        <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
          <label style="margin:0; font-size:0.85em; opacity:0.7; text-transform:uppercase; letter-spacing:0.08em;">Pack</label>
          <select id="descriptorPackSelect" onchange="refreshDescriptors()" style="min-width: 200px;">
            <option value="">(All packs)</option>
          </select>
        </div>
      </div>

      <!-- Relevant chips -->
      <div id="relevantChips" style="display:flex; gap:0.5rem; flex-wrap:wrap;"></div>

      <!-- Search -->
      <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
        <input type="text" id="descriptorSearch" placeholder="Search descriptors..." oninput="debouncedRefreshDescriptors()" style="flex:1; min-width:240px;">
        <button type="button" class="btn-secondary" onclick="refreshDescriptors(true)">Search</button>
        <span id="descriptorStatus" style="font-size:0.9em; opacity:0.7;"></span>
      </div>

      <!-- Results -->
      <div id="descriptorResults"
           style="border:1px solid #333; border-radius:8px; max-height:320px; overflow:auto; background:#111; padding:0.5rem;">
        <div style="opacity:0.7; padding:0.75rem;">Type in the search box or pick a pack to load descriptors.</div>
      </div>

      <div style="font-size:0.9em; opacity:0.75;">
        Clicking a descriptor inserts a token like <code style="opacity:0.9;">{{"{{"}}descriptor:123{{"}}"}}</code> into the editor.
      </div>
    </div>
  </details>

  <form action="{{ url_for('refine_prompt', prompt_id=prompt.id) }}" method="POST">

    <div style="display:flex; justify-content:space-between; align-items:end; margin-bottom:0.5rem;">
      <label>Final Prompt (Editable)</label>
      <div style="display:flex; gap:0.75rem; align-items:center;">
        <span id="descriptorInsertFeedback" style="font-size:0.85em; color:#51cf66; opacity:0; transition:opacity 0.3s;">Inserted!</span>
        <span id="copyFeedback" style="font-size:0.85em; color:#51cf66; opacity:0; transition:opacity 0.3s;">Copied!</span>
      </div>
    </div>

    <textarea id="templateSource" style="display:none;">{{ final_text or prompt.content }}</textarea>
    <textarea name="content" id="finalOutput" rows="12" style="font-family:monospace; line-height:1.5; font-size:1.1em; padding:1rem;">{{ final_text or prompt.content }}</textarea>

    <div class="action-bar" style="margin-top:1rem; display:flex; gap:1rem; flex-wrap:wrap;">
      <button type="button" class="btn-primary" onclick="copyToClipboard()" style="flex:2;">Copy to Clipboard</button>

      <button type="submit" class="btn-secondary" style="flex:1;" title="Send this text to Ollama for refinement">‚ú® Refine with Ollama</button>

      <button type="submit" class="btn-secondary" style="flex:1;" name="save_mode" value="overwrite"
              formaction="{{ url_for('save_from_use', prompt_id=prompt.id) }}"
              title="Overwrite the saved prompt content with the text above">üíæ Save</button>

      <button type="submit" class="btn-secondary" style="flex:1;" name="save_mode" value="variant"
              formaction="{{ url_for('save_from_use', prompt_id=prompt.id) }}"
              title="Save this as a new child variant linked to this prompt">üìé Save as Variant</button>
    </div>
  </form>

</section>

<<script>
function updateFinal() {
  let text = document.getElementById('templateSource').value;
  const inputs = document.querySelectorAll('.placeholder-input');
  inputs.forEach(input => {
    const key = input.getAttribute('data-target');
    const val = input.value;
    if (val) {
      const regex = new RegExp(`\\[\\[${key}\\]\\]`, 'g');
      text = text.replace(regex, val);
    }
  });
  document.getElementById('finalOutput').value = text;
}

function copyToClipboard() {
  const text = document.getElementById('finalOutput').value;
  navigator.clipboard.writeText(text).then(() => {
    const feedback = document.getElementById('copyFeedback');
    feedback.style.opacity = '1';
    setTimeout(() => feedback.style.opacity = '0', 2000);
  });
}

/* =========================
   Descriptor picker logic
   ========================= */

const RELEVANT_PACKS_IMAGE = [
  "camera",
  "character",
  "creature",
  "environment",
  "scene",
  "action",
  "prop",
  "style"
];

let descriptorScope = "relevant";

function getRelevantPackTypes() {
  return RELEVANT_PACKS_IMAGE.slice();
}

function setDescriptorScope(scope) {
  descriptorScope = scope;

  const relevantBtn = document.getElementById("scopeRelevantBtn");
  const allBtn = document.getElementById("scopeAllBtn");

  if (scope === "relevant") {
    relevantBtn.style.borderColor = "#00bfff";
    relevantBtn.style.fontWeight = "bold";
    allBtn.style.borderColor = "";
    allBtn.style.fontWeight = "normal";
    document.getElementById("descriptorScopeHint").textContent = "(filtered)";
    renderRelevantChips();
    populatePackDropdown();
  } else {
    allBtn.style.borderColor = "#00bfff";
    allBtn.style.fontWeight = "bold";
    relevantBtn.style.borderColor = "";
    relevantBtn.style.fontWeight = "normal";
    document.getElementById("descriptorScopeHint").textContent = "(global)";
    document.getElementById("relevantChips").innerHTML = "";
    populatePackDropdown(true);
  }

  document.getElementById("descriptorPackSelect").value = "";
  refreshDescriptors();
}

function renderRelevantChips() {
  const wrap = document.getElementById("relevantChips");
  wrap.innerHTML = "";

  const types = getRelevantPackTypes();
  if (!types.length) return;

  const label = document.createElement("span");
  label.textContent = "Quick filters:";
  label.style.opacity = "0.7";
  label.style.fontSize = "0.9em";
  label.style.marginRight = "0.25rem";
  wrap.appendChild(label);

  types.forEach(t => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "btn-secondary";
    btn.textContent = t;
    btn.style.padding = "0.25rem 0.6rem";
    btn.style.fontSize = "0.9em";
    btn.onclick = () => {
      document.getElementById("descriptorPackSelect").value = t;
      refreshDescriptors(true);
    };
    wrap.appendChild(btn);
  });
}

function populatePackDropdown(allMode = false) {
  const select = document.getElementById("descriptorPackSelect");
  const current = select.value;

  select.innerHTML = `<option value="">(All packs)</option>`;

  const types = allMode ? getRelevantPackTypes() : getRelevantPackTypes();

  types.forEach(t => {
    const opt = document.createElement("option");
    opt.value = t;
    opt.textContent = t;
    select.appendChild(opt);
  });

  if ([...select.options].some(o => o.value === current)) {
    select.value = current;
  }
}

function buildDescriptorListUrl() {
  const q = (document.getElementById("descriptorSearch").value || "").trim();
  const packSel = (document.getElementById("descriptorPackSelect").value || "").trim();

  const params = new URLSearchParams();
  if (q) params.set("q", q);

  if (descriptorScope === "all") {
    if (packSel) params.set("pack_type", packSel);
  } else {
    if (packSel) params.set("pack_type", packSel);
  }

  return `/api/descriptors/list?${params.toString()}`;
}

function setDescriptorStatus(msg) {
  const el = document.getElementById("descriptorStatus");
  el.textContent = msg || "";
}

/* ---- insertion helpers ---- */

function flashInserted() {
  const feedback = document.getElementById("descriptorInsertFeedback");
  feedback.style.opacity = "1";
  setTimeout(() => feedback.style.opacity = "0", 1500);
}

function insertTextAtCursor(text) {
  const ta = document.getElementById("finalOutput");
  if (!ta) return;

  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  const before = ta.value.substring(0, start);
  const after = ta.value.substring(end);

  const needsSpaceBefore = before.length && !/\s$/.test(before);
  const needsSpaceAfter = after.length && !/^\s/.test(after);

  const insert = (needsSpaceBefore ? " " : "") + text + (needsSpaceAfter ? " " : "");
  ta.value = before + insert + after;

  const cursorPos = (before + (needsSpaceBefore ? " " : "") + text + (needsSpaceAfter ? " " : "")).length;
  ta.focus();
  ta.setSelectionRange(cursorPos, cursorPos);

  flashInserted();
}

function insertDescriptorText(d) {
  const text = (d && (d.rendered_text || d.description) ? (d.rendered_text || d.description) : "").trim();
  if (!text) return;
  insertTextAtCursor(text);
}

function insertDescriptorToken(id) {
  const ta = document.getElementById("finalOutput");
  if (!ta) return;

  // Build token without ever having '{{' / '}}' appear in the template source.
  const token = String.fromCharCode(123,123) + "descriptor:" + id + String.fromCharCode(125,125);
  insertTextAtCursor(token);
}

/* ---- render results ---- */

function renderDescriptorResults(items) {
  const box = document.getElementById("descriptorResults");
  box.innerHTML = "";

  if (!items || !items.length) {
    const empty = document.createElement("div");
    empty.style.opacity = "0.7";
    empty.style.padding = "0.75rem";
    empty.textContent = "No descriptors found.";
    box.appendChild(empty);
    return;
  }

  items.forEach(d => {
    const row = document.createElement("div");
    row.style.border = "1px solid #333";
    row.style.borderRadius = "8px";
    row.style.padding = "0.6rem 0.75rem";
    row.style.margin = "0.5rem";
    row.style.background = "#0e0e0e";
    row.style.cursor = "pointer";

    const title = document.createElement("div");
    title.textContent = d.title || "(Untitled)";
    title.style.fontWeight = "bold";
    title.style.marginBottom = "0.25rem";

    const meta = document.createElement("div");
    meta.style.opacity = "0.7";
    meta.style.fontSize = "0.85em";
    meta.textContent = `${d.pack_type || "unknown"} ‚Ä¢ ID ${d.id}`;

    const preview = document.createElement("div");
    preview.style.marginTop = "0.4rem";
    preview.style.opacity = "0.9";
    preview.style.fontSize = "0.95em";
    preview.style.whiteSpace = "pre-wrap";
    preview.style.lineHeight = "1.35";
    preview.textContent = (d.rendered_text || d.description || "").slice(0, 220);

    row.appendChild(title);
    row.appendChild(meta);
    if (preview.textContent) row.appendChild(preview);

    // Default behaviour: insert editable text
    row.onclick = () => insertDescriptorText(d);

    // Actions row
    const actions = document.createElement("div");
    actions.style.marginTop = "0.55rem";
    actions.style.display = "flex";
    actions.style.gap = "0.5rem";
    actions.style.flexWrap = "wrap";

    const btnText = document.createElement("button");
    btnText.type = "button";
    btnText.className = "btn-secondary";
    btnText.textContent = "Insert text";
    btnText.style.padding = "0.25rem 0.6rem";
    btnText.style.fontSize = "0.9em";
    btnText.onclick = (e) => { e.stopPropagation(); insertDescriptorText(d); };

    const btnToken = document.createElement("button");
    btnToken.type = "button";
    btnToken.className = "btn-secondary";
    btnToken.textContent = "Token";
    btnToken.style.padding = "0.25rem 0.6rem";
    btnToken.style.fontSize = "0.9em";
    btnToken.title = "Insert as a descriptor reference token";
    btnToken.onclick = (e) => { e.stopPropagation(); insertDescriptorToken(d.id); };

    actions.appendChild(btnText);
    actions.appendChild(btnToken);
    row.appendChild(actions);

    box.appendChild(row);
  });
}

/* ---- fetch + refresh ---- */

async function fetchDescriptors(url) {
  const res = await fetch(url, { method: "GET" });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return await res.json();
}

async function fetchRelevantMerged(q) {
  const packTypes = getRelevantPackTypes();
  const paramsBase = new URLSearchParams();
  if (q) paramsBase.set("q", q);

  const all = [];
  for (const t of packTypes) {
    const params = new URLSearchParams(paramsBase);
    params.set("pack_type", t);
    const url = `/api/descriptors/list?${params.toString()}`;
    try {
      const chunk = await fetchDescriptors(url);
      if (Array.isArray(chunk)) all.push(...chunk);
    } catch (e) {}
  }

  const seen = new Set();
  const deduped = [];
  for (const item of all) {
    if (!item || typeof item.id === "undefined") continue;
    if (seen.has(item.id)) continue;
    seen.add(item.id);
    deduped.push(item);
  }

  deduped.sort((a, b) => {
    const ap = (a.pack_type || "").toLowerCase();
    const bp = (b.pack_type || "").toLowerCase();
    if (ap < bp) return -1;
    if (ap > bp) return 1;
    const at = (a.title || "").toLowerCase();
    const bt = (b.title || "").toLowerCase();
    if (at < bt) return -1;
    if (at > bt) return 1;
    return 0;
  });

  return deduped;
}

async function refreshDescriptors(force = false) {
  const q = (document.getElementById("descriptorSearch").value || "").trim();
  const packSel = (document.getElementById("descriptorPackSelect").value || "").trim();

  if (descriptorScope === "relevant" && !packSel && !q && !force) {
    setDescriptorStatus("Pick a pack or type a search‚Ä¶");
    renderDescriptorResults([]);
    return;
  }

  setDescriptorStatus("Loading‚Ä¶");

  try {
    let items = [];

    if (descriptorScope === "relevant" && !packSel) {
      items = await fetchRelevantMerged(q);
    } else {
      const url = buildDescriptorListUrl();
      const data = await fetchDescriptors(url);
      items = Array.isArray(data) ? data : [];
    }

    setDescriptorStatus(items.length ? `${items.length} found` : "No results");
    renderDescriptorResults(items);
  } catch (e) {
    setDescriptorStatus("Failed to load");
    const box = document.getElementById("descriptorResults");
    box.innerHTML = `<div style="opacity:0.8; padding:0.75rem;">Could not load descriptors. Check that <code>/api/descriptors/list</code> is available.</div>`;
  }
}

let _descTimer = null;
function debouncedRefreshDescriptors() {
  clearTimeout(_descTimer);
  _descTimer = setTimeout(() => refreshDescriptors(false), 250);
}

(function initDescriptorPicker() {
  setDescriptorScope("relevant");
  populatePackDropdown(false);
  renderRelevantChips();
  setDescriptorStatus("Pick a pack or type a search‚Ä¶");
})();
</script>

{% endblock %}
