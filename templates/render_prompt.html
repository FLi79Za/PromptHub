{% extends "base.html" %}

{% block content %}
<section class="page" style="max-width: 980px; margin: 0 auto;">

  <div class="page-header" style="display:flex; justify-content:space-between; align-items:flex-end; gap:1rem; flex-wrap:wrap;">
    <div>
      <h2 style="margin:0;">Use Prompt</h2>
      <h3 style="margin:0; opacity: 0.6; font-weight: normal;">{{ prompt.title }}</h3>
    </div>

    <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
      <a class="btn-secondary" href="{{ url_for('prompt_history', prompt_id=prompt.id) }}">History</a>
      <a class="btn-secondary" href="{{ url_for('edit_prompt', prompt_id=prompt.id) }}">Edit</a>
      <a class="btn-secondary" href="{{ url_for('index') }}">Back</a>
    </div>
  </div>

  <input type="hidden" id="promptId" value="{{ prompt.id }}">

  {% if placeholders %}
  <div style="background:#1a1a1a; padding:1.5rem; border-radius:8px; margin-bottom:2rem; border:1px solid #333;">
    <h4 style="margin-top:0; color:#00bfff; margin-bottom:1rem;">Variables</h4>
    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:1rem;">
      {% for name in placeholders %}
      <div>
        <label style="font-size:0.85em; text-transform:uppercase; letter-spacing:1px; opacity:0.7;">{{ name }}</label>
        <input type="text" class="placeholder-input" data-target="{{ name }}" oninput="updateFinal()" placeholder="Value for {{ name }}..." style="width:100%;">
      </div>
      {% endfor %}
    </div>
  </div>
  {% endif %}

  <!-- Descriptor picker (Use-stage only) -->
  <details id="descriptorPanel" style="background:#1a1a1a; padding:1rem; border-radius:8px; margin-bottom:1rem; border:1px solid #333;">
    <summary style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:space-between; gap:1rem;">
      <span style="font-weight:bold;">üß© Insert Descriptors</span>
      <span style="opacity:0.7; font-size:0.9em;">Click to toggle</span>
    </summary>

    <div style="margin-top:1rem; display:flex; flex-direction:column; gap:0.75rem;">
      <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; justify-content:space-between;">
        <!-- Scope toggle -->
        <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
          <span style="font-size:0.85em; opacity:0.7; text-transform:uppercase; letter-spacing:0.08em;">Scope</span>

          <div style="display:flex; gap:0.5rem; align-items:center;">
            <button type="button" class="btn-secondary" id="scopeRelevantBtn" onclick="setDescriptorScope('relevant')" title="Show quick filters (does not hide types)">
              Relevant only
            </button>
            <button type="button" class="btn-secondary" id="scopeAllBtn" onclick="setDescriptorScope('all')" title="Show all types">
              All
            </button>
          </div>

          <span id="descriptorScopeHint" style="font-size:0.9em; opacity:0.7;"></span>
        </div>

        <!-- Pack type dropdown -->
        <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
          <label style="margin:0; font-size:0.85em; opacity:0.7; text-transform:uppercase; letter-spacing:0.08em;">Pack</label>
          <select id="descriptorPackSelect" onchange="refreshDescriptors()" style="min-width: 200px;">
            <option value="all">(All packs)</option>
          </select>
        </div>
      </div>

      <!-- Relevant chips -->
      <div id="relevantChips" style="display:flex; gap:0.5rem; flex-wrap:wrap;"></div>

      <!-- Search -->
      <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
        <input type="text" id="descriptorSearch" placeholder="Search descriptors..." oninput="debouncedRefreshDescriptors()" style="flex:1; min-width:240px;">
        <button type="button" class="btn-secondary" onclick="refreshDescriptors(true)">Search</button>
        <span id="descriptorStatus" style="font-size:0.9em; opacity:0.7;"></span>
      </div>

      <!-- Results -->
      <div id="descriptorResults"
           style="border:1px solid #333; border-radius:8px; max-height:320px; overflow:auto; background:#111; padding:0.5rem;">
        <div style="opacity:0.7; padding:0.75rem;">Loading descriptors‚Ä¶</div>
      </div>

      <div style="font-size:0.9em; opacity:0.75;">
        Clicking a descriptor inserts a token like <code style="opacity:0.9;">{{"{{"}}descriptor:123{{"}}"}}</code> into the editor.
      </div>
    </div>
  </details>

  <form action="{{ url_for('refine_prompt', prompt_id=prompt.id) }}" method="POST">

    <div style="display:flex; justify-content:space-between; align-items:end; margin-bottom:0.5rem;">
      <label>Final Prompt (Editable)</label>
      <div style="display:flex; gap:0.75rem; align-items:center;">
        <span id="descriptorInsertFeedback" style="font-size:0.85em; color:#51cf66; opacity:0; transition:opacity 0.3s;">Inserted!</span>
        <span id="copyFeedback" style="font-size:0.85em; color:#51cf66; opacity:0; transition:opacity 0.3s;">Copied!</span>
        <span id="replaceFeedback" style="font-size:0.85em; color:#51cf66; opacity:0; transition:opacity 0.3s;">Replaced!</span>
      </div>
    </div>

    <!-- Find + Replace -->
    <details id="findReplacePanel" style="background:#1a1a1a; padding:1rem; border-radius:8px; margin-bottom:1rem; border:1px solid #333;">
      <summary style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:space-between; gap:1rem;">
        <span style="font-weight:bold;">üîé Find & Replace</span>
        <span style="opacity:0.7; font-size:0.9em;">Click to toggle</span>
      </summary>

      <div style="margin-top:1rem; display:flex; flex-direction:column; gap:0.75rem;">
        <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
          <input id="frFind" type="text" placeholder="Find‚Ä¶" style="flex:1; min-width:240px;">
          <input id="frReplace" type="text" placeholder="Replace with‚Ä¶" style="flex:1; min-width:240px;">
        </div>

        <div style="display:flex; gap:0.75rem; flex-wrap:wrap; align-items:center; justify-content:space-between;">
          <div style="display:flex; gap:0.75rem; flex-wrap:wrap; align-items:center;">
            <label style="display:flex; gap:0.4rem; align-items:center; opacity:0.85; font-size:0.95em; cursor:pointer;">
              <input id="frMatchCase" type="checkbox">
              Match case
            </label>
            <label style="display:flex; gap:0.4rem; align-items:center; opacity:0.85; font-size:0.95em; cursor:pointer;">
              <input id="frWholeWord" type="checkbox" checked>
              Whole word
            </label>
          </div>

          <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
            <button type="button" class="btn-secondary" onclick="frFindNext()">Find next</button>
            <button type="button" class="btn-secondary" onclick="frReplaceOne()">Replace</button>
            <button type="button" class="btn-secondary" onclick="frReplaceAll()">Replace all</button>
            <span id="frStatus" style="font-size:0.9em; opacity:0.7;"></span>
          </div>
        </div>

        <div style="font-size:0.9em; opacity:0.75;">
          Tip: with ‚ÄúWhole word‚Äù on, ‚Äúhe‚Äù won‚Äôt match inside ‚Äúthe‚Äù.
        </div>
      </div>
    </details>

    <!-- IMPORTANT: this is the immutable base template (with placeholders). DO NOT overwrite it in JS. -->
    <textarea id="templateSource" style="display:none;">{{ final_text or prompt.content }}</textarea>

    <textarea name="content" id="finalOutput" rows="12" style="font-family:monospace; line-height:1.5; font-size:1.1em; padding:1rem;">{{ final_text or prompt.content }}</textarea>

    <div class="action-bar" style="margin-top:1rem; display:flex; gap:1rem; flex-wrap:wrap;">
      <button type="button" class="btn-primary" onclick="copyToClipboard()" style="flex:2;">Copy to Clipboard</button>

      <button type="submit" class="btn-secondary" style="flex:1;" title="Send this text to Ollama for refinement">‚ú® Refine with Ollama</button>

      <button type="submit" class="btn-secondary" style="flex:1;" name="save_mode" value="overwrite"
              formaction="{{ url_for('save_from_use', prompt_id=prompt.id) }}"
              title="Overwrite the saved prompt content with the text above">üíæ Save</button>

      <button type="submit" class="btn-secondary" style="flex:1;" name="save_mode" value="variant"
              formaction="{{ url_for('save_from_use', prompt_id=prompt.id) }}"
              title="Save this as a new child variant linked to this prompt">üìé Save as Variant</button>
    </div>
  </form>

</section>

<script>
/* =========================
   Variables: placeholder fill
   ========================= */

function updateFinal() {
  // Use the immutable base template every time.
  // Do NOT sync it back, or the placeholder disappears after the first character.
  let text = document.getElementById("templateSource").value;

  const inputs = document.querySelectorAll(".placeholder-input");
  inputs.forEach(input => {
    const key = input.getAttribute("data-target");
    const val = input.value;
    if (val) {
      const regex = new RegExp(`\\[\\[${key}\\]\\]`, "g");
      text = text.replace(regex, val);
    }
  });

  document.getElementById("finalOutput").value = text;
}

function copyToClipboard() {
  const textarea = document.getElementById("finalOutput");
  textarea.select();
  textarea.setSelectionRange(0, 999999);
  navigator.clipboard.writeText(textarea.value);

  // Record usage history (best-effort)
  try {
    const idEl = document.getElementById("promptId");
    const pid = idEl ? parseInt(idEl.value, 10) : null;
    if (pid) {
      fetch("/api/prompt/" + pid + "/usage", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ content: textarea.value, source: "use" })
      }).catch(() => {});
    }
  } catch (e) {
    // ignore
  }

  const feedback = document.getElementById("copyFeedback");
  feedback.style.opacity = "1";
  setTimeout(() => feedback.style.opacity = "0", 1500);
}

/* =========================
   Find & Replace (Use page)
   ========================= */

let _frLastIndex = 0;

function frGetTextArea() {
  return document.getElementById("finalOutput");
}

function frSetStatus(msg) {
  const el = document.getElementById("frStatus");
  el.textContent = msg || "";
}

function frFlash() {
  const feedback = document.getElementById("replaceFeedback");
  feedback.style.opacity = "1";
  setTimeout(() => feedback.style.opacity = "0", 1500);
}

function frBuildRegex() {
  const find = document.getElementById("frFind").value || "";
  const matchCase = document.getElementById("frMatchCase").checked;
  const wholeWord = document.getElementById("frWholeWord").checked;

  const flags = matchCase ? "g" : "gi";
  const escaped = find.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const pattern = wholeWord ? `\\b${escaped}\\b` : escaped;

  return { re: new RegExp(pattern, flags), find };
}

function frFindNext() {
  const ta = frGetTextArea();
  const text = ta.value;
  const rebuilt = frBuildRegex();

  if (!rebuilt.find) {
    frSetStatus("Enter text to find.");
    return;
  }

  rebuilt.re.lastIndex = _frLastIndex;

  const m = rebuilt.re.exec(text);
  if (!m) {
    // wrap
    _frLastIndex = 0;
    rebuilt.re.lastIndex = 0;
    const m2 = rebuilt.re.exec(text);
    if (!m2) {
      frSetStatus("No matches.");
      return;
    }
    ta.focus();
    ta.setSelectionRange(m2.index, m2.index + m2[0].length);
    _frLastIndex = m2.index + Math.max(1, m2[0].length);
    frSetStatus("Wrapped to start.");
    return;
  }

  ta.focus();
  ta.setSelectionRange(m.index, m.index + m[0].length);
  _frLastIndex = m.index + Math.max(1, m[0].length);
  frSetStatus("Match found.");
}

function frReplaceOne() {
  const ta = frGetTextArea();
  const find = document.getElementById("frFind").value || "";
  const rep = document.getElementById("frReplace").value || "";

  if (!find) {
    frSetStatus("Enter text to find.");
    return;
  }

  // Replace current selection if it matches, else find next and replace that.
  const sel = ta.value.substring(ta.selectionStart, ta.selectionEnd);
  const rebuilt = frBuildRegex();

  if (sel && rebuilt.re.test(sel)) {
    const before = ta.value.substring(0, ta.selectionStart);
    const after = ta.value.substring(ta.selectionEnd);
    const start = ta.selectionStart;

    ta.value = before + rep + after;
    ta.focus();
    ta.setSelectionRange(start, start + rep.length);

    _frLastIndex = start + Math.max(1, rep.length);
    frSetStatus("Replaced 1.");
    frFlash();
    return;
  }

  // If selection didn't match, find next match and replace it.
  const text = ta.value;
  rebuilt.re.lastIndex = _frLastIndex;

  const m = rebuilt.re.exec(text) || (rebuilt.re.lastIndex = 0, rebuilt.re.exec(text));
  if (!m) {
    frSetStatus("No matches.");
    return;
  }

  const before = text.substring(0, m.index);
  const after = text.substring(m.index + m[0].length);
  ta.value = before + rep + after;

  ta.focus();
  ta.setSelectionRange(m.index, m.index + rep.length);

  _frLastIndex = m.index + Math.max(1, rep.length);
  frSetStatus("Replaced 1.");
  frFlash();
}

function frReplaceAll() {
  const ta = frGetTextArea();
  const rep = document.getElementById("frReplace").value || "";
  const rebuilt = frBuildRegex();

  if (!rebuilt.find) {
    frSetStatus("Enter text to find.");
    return;
  }

  const before = ta.value;
  const after = before.replace(rebuilt.re, rep);

  if (before === after) {
    frSetStatus("No matches.");
    return;
  }

  ta.value = after;
  ta.focus();
  _frLastIndex = 0;

  const count = (before.match(rebuilt.re) || []).length;
  frSetStatus(`Replaced ${count}.`);
  frFlash();
}

/* =========================
   Descriptor picker (Use-stage)
   ========================= */

let _descriptorTypes = [];
let _descTypesLoaded = false;
let _descScopeUiMode = "all";

const DESC_PREFERRED_ORDER = [
  "character", "creature", "environment", "scene", "action", "camera", "lighting", "style", "prop", "vehicle"
];

function setDescriptorScope(mode) {
  _descScopeUiMode = (mode === "relevant") ? "relevant" : "all";

  const btnRel = document.getElementById("scopeRelevantBtn");
  const btnAll = document.getElementById("scopeAllBtn");
  if (btnRel) btnRel.style.opacity = _descScopeUiMode === "relevant" ? "1" : "0.65";
  if (btnAll) btnAll.style.opacity = _descScopeUiMode === "all" ? "1" : "0.65";

  const hint = document.getElementById("descriptorScopeHint");
  if (_descScopeUiMode === "relevant") {
    if (hint) hint.textContent = "(quick filters)";
  } else {
    if (hint) hint.textContent = "(all types)";
  }

  renderRelevantChips();
}

async function loadDescriptorTypesOnce() {
  if (_descTypesLoaded) return _descriptorTypes;

  try {
    const res = await fetch("/api/descriptors/types", { headers: { "Accept": "application/json" } });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const types = await res.json();
    _descriptorTypes = Array.isArray(types) ? types.filter(Boolean).map(t => String(t)) : [];
  } catch (e) {
    // Fallback: keep UI functional even if the types endpoint is unavailable.
    _descriptorTypes = [];
  }

  // Ensure we always have at least something usable
  const fallback = ["generic", "character", "creature", "environment", "scene", "action", "prop", "style", "lighting", "vehicle", "other"];
  const set = new Set(_descriptorTypes.map(t => t.trim()).filter(Boolean));
  fallback.forEach(t => set.add(t));

  _descriptorTypes = Array.from(set).sort((a, b) => a.localeCompare(b));
  _descTypesLoaded = true;
  return _descriptorTypes;
}

function getQuickChipTypes() {
  const types = _descriptorTypes.slice();

  // Keep only known / common types for chips, but do not block anything from dropdown.
  const lower = new Set(types.map(t => String(t).toLowerCase()));
  const ordered = [];

  DESC_PREFERRED_ORDER.forEach(t => {
    if (lower.has(t)) ordered.push(t);
  });

  // Add a few more (if present) until we hit a sensible cap
  const extras = types
    .map(t => String(t).toLowerCase())
    .filter(t => !ordered.includes(t) && t !== "generic" && t !== "other")
    .slice(0, 8);

  return (_descScopeUiMode === "relevant") ? ordered.concat(extras) : types.map(t => String(t).toLowerCase());
}

function renderRelevantChips() {
  const wrap = document.getElementById("relevantChips");
  if (!wrap) return;

  wrap.innerHTML = "";

  const types = getQuickChipTypes();
  if (!types.length) return;

  const label = document.createElement("span");
  label.textContent = "Quick filters:";
  label.style.opacity = "0.7";
  label.style.fontSize = "0.9em";
  label.style.marginRight = "0.25rem";
  wrap.appendChild(label);

  // De-dupe while keeping order
  const seen = new Set();
  types.forEach(t => {
    const key = String(t).toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "btn-secondary";
    btn.textContent = key;
    btn.style.padding = "0.25rem 0.6rem";
    btn.style.fontSize = "0.9em";
    btn.onclick = () => {
      const sel = document.getElementById("descriptorPackSelect");
      if (sel) sel.value = key;
      refreshDescriptors(true);
    };
    wrap.appendChild(btn);
  });
}

function populatePackDropdown() {
  const select = document.getElementById("descriptorPackSelect");
  if (!select) return;

  const current = select.value;

  // Always include "All packs" option
  select.innerHTML = "<option value=\"all\">(All packs)</option>";

  // Use the loaded types so lighting and other custom pack types appear.
  const types = _descriptorTypes.slice().map(t => String(t).toLowerCase());
  const seen = new Set();
  types.forEach(t => {
    const key = t.trim();
    if (!key || seen.has(key)) return;
    seen.add(key);

    const opt = document.createElement("option");
    opt.value = key;
    opt.textContent = key;
    select.appendChild(opt);
  });

  // Preserve selection if still present
  if ([...select.options].some(o => o.value === current)) {
    select.value = current;
  } else {
    select.value = "all";
  }
}

function buildDescriptorListUrl() {
  const q = (document.getElementById("descriptorSearch")?.value || "").trim();
  const packSel = (document.getElementById("descriptorPackSelect")?.value || "all").trim();

  const params = new URLSearchParams();
  if (q) params.set("q", q);
  if (packSel && packSel !== "all") params.set("pack_type", packSel);

  return `/api/descriptors/list?${params.toString()}`;
}

function setDescriptorStatus(msg) {
  const el = document.getElementById("descriptorStatus");
  if (el) el.textContent = msg || "";
}

/* ---- insertion helpers ---- */

function flashInserted() {
  const feedback = document.getElementById("descriptorInsertFeedback");
  if (!feedback) return;
  feedback.style.opacity = "1";
  setTimeout(() => feedback.style.opacity = "0", 1500);
}

function insertTextAtCursor(text) {
  const ta = document.getElementById("finalOutput");
  if (!ta) return;

  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  const before = ta.value.substring(0, start);
  const after = ta.value.substring(end);

  const needsSpaceBefore = before.length && !/\s$/.test(before);
  const needsSpaceAfter = after.length && !/^\s/.test(after);

  const insert = (needsSpaceBefore ? " " : "") + text + (needsSpaceAfter ? " " : "");
  ta.value = before + insert + after;

  const cursorPos = (before + (needsSpaceBefore ? " " : "") + text + (needsSpaceAfter ? " " : "")).length;
  ta.focus();
  ta.setSelectionRange(cursorPos, cursorPos);

  flashInserted();
}

function insertDescriptorText(d) {
  const text = (d && (d.rendered_text || d.description) ? (d.rendered_text || d.description) : "").trim();
  if (!text) return;
  insertTextAtCursor(text);
}

function insertDescriptorToken(id) {
  const token = String.fromCharCode(123,123) + "descriptor:" + id + String.fromCharCode(125,125);
  insertTextAtCursor(token);
}

/* ---- render results ---- */

function renderDescriptorResults(items) {
  const box = document.getElementById("descriptorResults");
  if (!box) return;

  box.innerHTML = "";

  if (!items || !items.length) {
    const empty = document.createElement("div");
    empty.style.opacity = "0.7";
    empty.style.padding = "0.75rem";
    empty.textContent = "No descriptors found.";
    box.appendChild(empty);
    return;
  }

  items.forEach(d => {
    const row = document.createElement("div");
    row.style.border = "1px solid #333";
    row.style.borderRadius = "8px";
    row.style.padding = "0.6rem 0.75rem";
    row.style.margin = "0.5rem";
    row.style.background = "#0e0e0e";
    row.style.cursor = "pointer";

    const title = document.createElement("div");
    title.textContent = d.title || "(Untitled)";
    title.style.fontWeight = "bold";
    title.style.marginBottom = "0.25rem";

    const meta = document.createElement("div");
    meta.style.opacity = "0.7";
    meta.style.fontSize = "0.85em";
    meta.textContent = `${(d.pack_type || "unknown")} ‚Ä¢ ID ${d.id}`;

    const preview = document.createElement("div");
    preview.style.marginTop = "0.4rem";
    preview.style.opacity = "0.9";
    preview.style.fontSize = "0.95em";
    preview.style.whiteSpace = "pre-wrap";
    preview.style.lineHeight = "1.35";
    preview.textContent = (d.rendered_text || d.description || "").slice(0, 220);

    row.appendChild(title);
    row.appendChild(meta);
    if (preview.textContent) row.appendChild(preview);

    row.onclick = () => insertDescriptorText(d);

    const actions = document.createElement("div");
    actions.style.marginTop = "0.55rem";
    actions.style.display = "flex";
    actions.style.gap = "0.5rem";
    actions.style.flexWrap = "wrap";

    const btnText = document.createElement("button");
    btnText.type = "button";
    btnText.className = "btn-secondary";
    btnText.textContent = "Insert text";
    btnText.style.padding = "0.25rem 0.6rem";
    btnText.style.fontSize = "0.9em";
    btnText.onclick = (e) => { e.stopPropagation(); insertDescriptorText(d); };

    const btnToken = document.createElement("button");
    btnToken.type = "button";
    btnToken.className = "btn-secondary";
    btnToken.textContent = "Token";
    btnToken.style.padding = "0.25rem 0.6rem";
    btnToken.style.fontSize = "0.9em";
    btnToken.title = "Insert as a descriptor reference token";
    btnToken.onclick = (e) => { e.stopPropagation(); insertDescriptorToken(d.id); };

    actions.appendChild(btnText);
    actions.appendChild(btnToken);
    row.appendChild(actions);

    box.appendChild(row);
  });
}

/* ---- fetch + refresh ---- */

async function fetchDescriptors(url) {
  const res = await fetch(url, { method: "GET", headers: { "Accept": "application/json" } });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return await res.json();
}

async function refreshDescriptors() {
  const q = (document.getElementById("descriptorSearch")?.value || "").trim();
  const packSel = (document.getElementById("descriptorPackSelect")?.value || "all").trim();

  setDescriptorStatus("Loading‚Ä¶");

  try {
    const url = buildDescriptorListUrl();
    const data = await fetchDescriptors(url);
    const items = Array.isArray(data) ? data : [];

    // If the user picked a pack type that no longer exists, reset to all
    if (packSel !== "all" && _descriptorTypes.length) {
      const lower = new Set(_descriptorTypes.map(t => String(t).toLowerCase()));
      if (!lower.has(packSel.toLowerCase())) {
        const sel = document.getElementById("descriptorPackSelect");
        if (sel) sel.value = "all";
      }
    }

    setDescriptorStatus(items.length ? `${items.length} found` : (q ? "No results" : "No descriptors"));
    renderDescriptorResults(items);
  } catch (e) {
    setDescriptorStatus("Failed to load");
    const box = document.getElementById("descriptorResults");
    if (box) {
      box.innerHTML = "<div style=\"opacity:0.8; padding:0.75rem;\">Could not load descriptors. Check that <code>/api/descriptors/list</code> is available.</div>";
    }
  }
}

let _descTimer = null;
function debouncedRefreshDescriptors() {
  clearTimeout(_descTimer);
  _descTimer = setTimeout(() => refreshDescriptors(), 250);
}

(async function initDescriptorPicker() {
  await loadDescriptorTypesOnce();
  populatePackDropdown();
  setDescriptorScope("all"); // default matches edit/create behaviour (show everything)
  renderRelevantChips();
  refreshDescriptors();
})();
</script>

{% endblock %}
