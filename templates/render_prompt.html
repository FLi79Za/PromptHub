{% extends "base.html" %}

{% block content %}
<section class="page" style="max-width: 980px; margin: 0 auto;">

  <div class="page-header" style="display:flex; justify-content:space-between; align-items:flex-end; gap:1rem; flex-wrap:wrap;">
    <div>
      <h2 style="margin:0;">Use Prompt</h2>
      <h3 style="margin:0; opacity: 0.6; font-weight: normal;">{{ prompt.title }}</h3>
    </div>

    <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
      <a class="btn-secondary" href="{{ url_for('prompt_history', prompt_id=prompt.id) }}">History</a>
      <a class="btn-secondary" href="{{ url_for('edit_prompt', prompt_id=prompt.id) }}">Edit</a>
      <a class="btn-secondary" href="{{ url_for('index') }}">Back</a>
    </div>
  </div>

  <input type="hidden" id="promptId" value="{{ prompt.id }}">

  <form id="useForm" action="{{ url_for('refine_prompt', prompt_id=prompt.id) }}" method="POST">
    <input type="hidden" name="use_render" value="1">
    <input type="hidden" name="override_active" id="overrideActive" value="0">
    <input type="hidden" name="final_override" id="finalOverride" value="">

    <!-- PATCH 1: Notes panel (insert after promptId, before the form) -->
{% if prompt.notes %}
<details id="notesPanel" style="background:#1a1a1a; padding:1.25rem; border-radius:8px; margin:1.25rem 0 1.25rem; border:1px solid #333;">
  <summary style="cursor:pointer; user-select:none; display:flex; align-items:baseline; justify-content:space-between; gap:1rem; flex-wrap:wrap;">
    <h4 style="margin:0;">üóíÔ∏è Notes</h4>
    <div style="opacity:0.7; font-size:0.95em;">Click to toggle</div>
  </summary>

  <div style="margin-top:0.9rem; white-space:pre-wrap; line-height:1.45; opacity:0.92;">{{ prompt.notes }}</div>
</details>
{% endif %}


<!-- PATCH 2: Variables block (replace your entire placeholders_meta section with this) -->
{% if placeholders_meta %}
<details id="variablesPanel" style="background:#1a1a1a; padding:1.25rem; border-radius:8px; margin:1.25rem 0 1.25rem; border:1px solid #333;">
  <summary style="cursor:pointer; user-select:none; display:flex; align-items:baseline; justify-content:space-between; gap:1rem; flex-wrap:wrap;">
    <h4 style="margin:0; color:#00bfff;">Variables</h4>
    <div style="opacity:0.7; font-size:0.95em;">Fill placeholders with a descriptor or custom text.</div>
  </summary>

  <div id="placeholderGrid" style="margin-top:1rem; display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:1rem;">
    {% for ph in placeholders_meta %}
    <div class="ph-card" data-ph-index="{{ loop.index0 }}" data-ph-key="{{ ph.key }}" data-ph-display="{{ ph.display }}" style="border:1px solid #333; border-radius:10px; background:#111; padding:0.9rem;">
      <div style="display:flex; align-items:baseline; justify-content:space-between; gap:0.75rem;">
        <div style="font-weight:bold;">{{ ph.display }}</div>
        <div style="display:flex; gap:0.5rem; align-items:center;">
          <label style="font-size:0.85em; opacity:0.75;">Mode</label>
          <select name="ph_mode_{{ loop.index0 }}" class="ph-mode" style="min-width: 140px;">
            <option value="text" selected>Custom</option>
            <option value="descriptor">Descriptor</option>
          </select>
        </div>
      </div>

      <input type="hidden" name="ph_key_{{ loop.index0 }}" value="{{ ph.key }}">

      <div class="ph-descriptor" style="margin-top:0.75rem; display:none;">
        <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; justify-content:space-between;">
          <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
            <label style="font-size:0.85em; opacity:0.75;">Pack</label>
            <select name="ph_pack_{{ loop.index0 }}" class="ph-pack" style="min-width: 180px;">
              <option value="all">(All packs)</option>
            </select>
          </div>

          <button type="button" class="btn-secondary ph-clear" title="Clear this placeholder">Clear</button>
        </div>

        <div style="margin-top:0.5rem; display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
          <input type="text" class="ph-search" placeholder="Search descriptors‚Ä¶" style="flex:1; min-width:200px;">
          <button type="button" class="btn-secondary ph-search-btn">Search</button>
        </div>

        <div class="ph-results" style="margin-top:0.6rem; border:1px solid #333; border-radius:8px; max-height:220px; overflow:auto; background:#0e0e0e; padding:0.35rem;">
          <div style="opacity:0.7; padding:0.6rem;">Search to load descriptors‚Ä¶</div>
        </div>

        <input type="hidden" name="ph_desc_text_{{ loop.index0 }}" class="ph-desc-text" value="">
      </div>

      <div class="ph-text" style="margin-top:0.75rem; display:block;">
        <input type="text" name="ph_text_{{ loop.index0 }}" class="ph-text-input" placeholder="Type a value‚Ä¶" style="width:100%;">
      </div>

      <div style="margin-top:0.7rem;">
        <div style="font-size:0.8em; opacity:0.7; text-transform:uppercase; letter-spacing:0.08em;">Selected text</div>
        <div class="ph-preview" style="margin-top:0.35rem; white-space:pre-wrap; line-height:1.35; opacity:0.92;"></div>
      </div>
    </div>
    {% endfor %}
  </div>
</details>
{% endif %}

<!-- Risk scan:
- No changes inside <script>
- No new literal template delimiters inside JS strings/comments
- Only added/converted HTML blocks using intended Jinja tags
-->


    <!-- Descriptor picker (Use-stage only, free insertion into editor) -->
    <details id="descriptorPanel" style="background:#1a1a1a; padding:1rem; border-radius:8px; margin-bottom:1rem; border:1px solid #333;">
      <summary style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:space-between; gap:1rem;">
        <span style="font-weight:bold;">üß© Insert Descriptors</span>
        <span style="opacity:0.7; font-size:0.9em;">Click to toggle</span>
      </summary>

      <div style="margin-top:1rem; display:flex; flex-direction:column; gap:0.75rem;">
        <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; justify-content:space-between;">
          <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
            <span style="font-size:0.85em; opacity:0.7; text-transform:uppercase; letter-spacing:0.08em;">Scope</span>

            <div style="display:flex; gap:0.5rem; align-items:center;">
              <button type="button" class="btn-secondary" id="scopeRelevantBtn" onclick="setDescriptorScope('relevant')" title="Show quick filters (does not hide types)">
                Relevant only
              </button>
              <button type="button" class="btn-secondary" id="scopeAllBtn" onclick="setDescriptorScope('all')" title="Show all types">
                All
              </button>
            </div>

            <span id="descriptorScopeHint" style="font-size:0.9em; opacity:0.7;"></span>
          </div>

          <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
            <label style="margin:0; font-size:0.85em; opacity:0.7; text-transform:uppercase; letter-spacing:0.08em;">Pack</label>
            <select id="descriptorPackSelect" onchange="refreshDescriptors()" style="min-width: 200px;">
              <option value="all">(All packs)</option>
            </select>
          </div>
        </div>

        <div id="relevantChips" style="display:flex; gap:0.5rem; flex-wrap:wrap;"></div>

        <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
          <input type="text" id="descriptorSearch" placeholder="Search descriptors..." oninput="debouncedRefreshDescriptors()" style="flex:1; min-width:240px;">
          <button type="button" class="btn-secondary" onclick="refreshDescriptors(true)">Search</button>
          <span id="descriptorStatus" style="font-size:0.9em; opacity:0.7;"></span>
        </div>

        <div id="descriptorResults"
             style="border:1px solid #333; border-radius:8px; max-height:320px; overflow:auto; background:#111; padding:0.5rem;">
          <div style="opacity:0.7; padding:0.75rem;">Loading descriptors‚Ä¶</div>
        </div>

        <div style="font-size:0.9em; opacity:0.75;">
          Clicking a descriptor inserts rendered text into the editor. Tokens remain available in this panel for advanced workflows.
        </div>
      </div>
    </details>

        <div style="display:grid; grid-template-columns: 1fr; gap:0.5rem; margin: 1rem 0 1rem;">
      <label>Template Preview (shows where placeholders appear)</label>
      <textarea id="templatePreview" readonly style="width:100%; min-height:140px; resize:vertical; padding:0.75rem; border-radius:8px; border:1px solid #333; background:#0e0e0e; color:#e6e6e6; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace; font-size:0.92em; line-height:1.35;">{{ base_text }}</textarea>
      <div style="opacity:0.7; font-size:0.9em;">Tip: click a variable card to jump to its next occurrence in the template.</div>
    </div>

<div style="display:flex; justify-content:space-between; align-items:end; margin-bottom:0.5rem;">
      <label>Final Prompt (Editable)</label>
      <div style="display:flex; gap:0.75rem; align-items:center;">
        <span id="descriptorInsertFeedback" style="font-size:0.85em; color:#51cf66; opacity:0; transition:opacity 0.3s;">Inserted!</span>
        <span id="copyFeedback" style="font-size:0.85em; color:#51cf66; opacity:0; transition:opacity 0.3s;">Copied!</span>
        <span id="replaceFeedback" style="font-size:0.85em; color:#51cf66; opacity:0; transition:opacity 0.3s;">Replaced!</span>
      </div>
    </div>

    <!-- Find + Replace (unchanged) -->
    <details id="findReplacePanel" style="background:#1a1a1a; padding:1rem; border-radius:8px; margin-bottom:1rem; border:1px solid #333;">
      <summary style="cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:space-between; gap:1rem;">
        <span style="font-weight:bold;">üîé Find & Replace</span>
        <span style="opacity:0.7; font-size:0.9em;">Click to toggle</span>
      </summary>

      <div style="margin-top:1rem; display:flex; flex-direction:column; gap:0.75rem;">
        <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
          <input id="frFind" type="text" placeholder="Find‚Ä¶" style="flex:1; min-width:240px;">
          <input id="frReplace" type="text" placeholder="Replace with‚Ä¶" style="flex:1; min-width:240px;">
        </div>

        <div style="display:flex; gap:0.75rem; flex-wrap:wrap; align-items:center; justify-content:space-between;">
          <div style="display:flex; gap:0.75rem; flex-wrap:wrap; align-items:center;">
            <label style="display:flex; gap:0.4rem; align-items:center; opacity:0.85; font-size:0.95em; cursor:pointer;">
              <input id="frMatchCase" type="checkbox">
              Match case
            </label>
            <label style="display:flex; gap:0.4rem; align-items:center; opacity:0.85; font-size:0.95em; cursor:pointer;">
              <input id="frWholeWord" type="checkbox" checked>
              Whole word
            </label>
          </div>

          <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
            <button type="button" class="btn-secondary" onclick="frFindNext()">Find next</button>
            <button type="button" class="btn-secondary" onclick="frReplaceOne()">Replace</button>
            <button type="button" class="btn-secondary" onclick="frReplaceAll()">Replace all</button>
            <span id="frStatus" style="font-size:0.9em; opacity:0.7;"></span>
          </div>
        </div>

        <div style="font-size:0.9em; opacity:0.75;">
          Tip: with ‚ÄúWhole word‚Äù on, ‚Äúhe‚Äù won‚Äôt match inside ‚Äúthe‚Äù.
        </div>
      </div>
    </details>

    <!-- Immutable base template (with placeholders). Do not overwrite it in JS. -->
    <textarea id="templateSource" style="display:none;">{{ prompt.content }}</textarea>

    <textarea name="content" id="finalOutput" rows="12" style="font-family:monospace; line-height:1.5; font-size:1.1em; padding:1rem;">{{ final_text or prompt.content }}</textarea>

    <div class="action-bar" style="margin-top:1rem; display:flex; gap:1rem; flex-wrap:wrap;">
      <button type="button" class="btn-primary" onclick="copyToClipboardServer()" style="flex:2;">Copy to Clipboard</button>

      <button type="submit" class="btn-secondary" style="flex:1;" title="Send this text to Ollama for refinement">‚ú® Refine with Ollama</button>

      <button type="submit" class="btn-secondary" style="flex:1;" name="save_mode" value="overwrite"
              formaction="{{ url_for('save_from_use', prompt_id=prompt.id) }}"
              title="Overwrite the saved prompt content with the text above">üíæ Save</button>

      <button type="submit" class="btn-secondary" style="flex:1;" name="save_mode" value="variant"
              formaction="{{ url_for('save_from_use', prompt_id=prompt.id) }}"
              title="Save this as a new child variant linked to this prompt">üìé Save as Variant</button>
    </div>
  </form>

</section>

<script>
/* =========================
   Use Prompt: per-placeholder fills (descriptor or custom)
   Server remains the source of truth for final output.
   ========================= */

function normalisePlaceholderName(s) {
  if (s === null || s === undefined) return "";
  const trimmed = String(s).trim();
  return trimmed.replace(/\s+/g, " ").toLowerCase();
}

function getPlaceholderCards() {
  return Array.from(document.querySelectorAll(".ph-card"));
}

function getFillTextForCard(card) {
  const modeEl = card.querySelector(".ph-mode");
  const mode = modeEl ? String(modeEl.value || "text") : "text";

  if (mode === "descriptor") {
    const h = card.querySelector(".ph-desc-text");
    return h ? String(h.value || "") : "";
  }

  const t = card.querySelector(".ph-text-input");
  return t ? String(t.value || "") : "";
}

function buildFillsMap() {
  const fills = {};
  getPlaceholderCards().forEach(card => {
    const key = normalisePlaceholderName(card.getAttribute("data-ph-key") || "");
    if (!key) return;
    fills[key] = getFillTextForCard(card) || "";
  });
  return fills;
}

function clientPreviewFinal() {
  const template = document.getElementById("templateSource");
  const out = document.getElementById("finalOutput");
  if (!template || !out) return;

  const fills = buildFillsMap();
  let text = String(template.value || "");

  // Replace placeholders using the same matching approach as server (normalised key lookup)
  text = text.replace(/\[\[([\s\S]+?)\]\]/g, (full, inner) => {
    const key = normalisePlaceholderName(inner);
    const val = (fills[key] || "").trim();
    return val; // empty removes unfilled placeholders
  });

  // Basic whitespace tidy (keep it light; server does the canonical cleanup)
  text = text.replace(/[ \t]{2,}/g, " ");
  text = text.replace(/ *\n */g, "\n").trim();

  if (!isUserEditingFinal()) {
    out.value = text;
  }
}

function isUserEditingFinal() {
  const flag = document.getElementById("overrideActive");
  return flag && flag.value === "1";
}

function setUserEditedFinal(active) {
  const flag = document.getElementById("overrideActive");
  if (flag) flag.value = active ? "1" : "0";
}

function syncFinalOverride() {
  const out = document.getElementById("finalOutput");
  const hidden = document.getElementById("finalOverride");
  if (!out || !hidden) return;
  hidden.value = String(out.value || "");
}

function updateCardModeUI(card) {
  const modeEl = card.querySelector(".ph-mode");
  const mode = modeEl ? String(modeEl.value || "text") : "text";
  const d = card.querySelector(".ph-descriptor");
  const t = card.querySelector(".ph-text");

  if (d) d.style.display = (mode === "descriptor") ? "block" : "none";
  if (t) t.style.display = (mode === "text") ? "block" : "none";
}

function setCardPreview(card, text) {
  const box = card.querySelector(".ph-preview");
  if (box) box.textContent = (text || "").trim();
}

async function loadDescriptorTypes() {
  try {
    const res = await fetch("/api/descriptors/types", { headers: { "Accept": "application/json" } });
    if (!res.ok) throw new Error("types");
    const types = await res.json();
    if (!Array.isArray(types)) return [];
    return types.map(t => String(t).toLowerCase()).filter(Boolean);
  } catch (e) {
    return [];
  }
}

function populateAllPlaceholderPackSelects(types) {
  const fallback = ["generic", "character", "creature", "environment", "scene", "action", "prop", "style", "lighting", "vehicle", "other"];
  const set = new Set((types || []).map(t => String(t).trim()).filter(Boolean));
  fallback.forEach(t => set.add(t));

  const list = Array.from(set).sort((a, b) => a.localeCompare(b));

  getPlaceholderCards().forEach(card => {
    const sel = card.querySelector(".ph-pack");
    if (!sel) return;
    const current = sel.value || "all";

    sel.innerHTML = "<option value=\"all\">(All packs)</option>";
    list.forEach(t => {
      const opt = document.createElement("option");
      opt.value = t;
      opt.textContent = t;
      sel.appendChild(opt);
    });

    if ([...sel.options].some(o => o.value === current)) sel.value = current;
  });
}

function buildPlaceholderDescriptorListUrl(packType, q) {
  const params = new URLSearchParams();
  if (q) params.set("q", q);
  if (packType && packType !== "all") params.set("pack_type", packType);
  return "/api/descriptors/list?" + params.toString();
}


async function fetchDescriptorList(packType, q) {
  const url = buildPlaceholderDescriptorListUrl(packType, q);
  const res = await fetch(url, { method: "GET", headers: { "Accept": "application/json" } });
  if (!res.ok) throw new Error("list");
  const data = await res.json();
  return Array.isArray(data) ? data : [];
}

function renderPlaceholderResults(card, items) {
  const box = card.querySelector(".ph-results");
  if (!box) return;

  box.innerHTML = "";

  if (!items || !items.length) {
    const empty = document.createElement("div");
    empty.style.opacity = "0.7";
    empty.style.padding = "0.6rem";
    empty.textContent = "No descriptors found.";
    box.appendChild(empty);
    return;
  }

  items.forEach(d => {
    const row = document.createElement("div");
    row.style.border = "1px solid #333";
    row.style.borderRadius = "8px";
    row.style.padding = "0.55rem 0.65rem";
    row.style.margin = "0.35rem";
    row.style.background = "#0b0b0b";
    row.style.cursor = "pointer";

    const title = document.createElement("div");
    title.textContent = d.title || "(Untitled)";
    title.style.fontWeight = "bold";
    title.style.marginBottom = "0.2rem";

    const meta = document.createElement("div");
    meta.style.opacity = "0.7";
    meta.style.fontSize = "0.85em";
    meta.textContent = (d.pack_type || "unknown") + " ‚Ä¢ ID " + d.id;

    const preview = document.createElement("div");
    preview.style.marginTop = "0.35rem";
    preview.style.opacity = "0.9";
    preview.style.fontSize = "0.95em";
    preview.style.whiteSpace = "pre-wrap";
    preview.style.lineHeight = "1.35";
    preview.textContent = String(d.rendered_text || d.description || "").slice(0, 220);

    row.appendChild(title);
    row.appendChild(meta);
    if (preview.textContent) row.appendChild(preview);

    row.onclick = () => {
      const txt = String(d.rendered_text || d.description || "").trim();
      const hidden = card.querySelector(".ph-desc-text");
      if (hidden) hidden.value = txt;
      setCardPreview(card, txt);
      clientPreviewFinal();
    };

    box.appendChild(row);
  });
}

function attachPlaceholderHandlers() {
  getPlaceholderCards().forEach(card => {
    updateCardModeUI(card);

    const mode = card.querySelector(".ph-mode");
    if (mode) {
      mode.addEventListener("change", () => {
        updateCardModeUI(card);
        clientPreviewFinal();
      });
    }

    const txt = card.querySelector(".ph-text-input");
    if (txt) {
      txt.addEventListener("input", () => {
        setCardPreview(card, txt.value || "");
        clientPreviewFinal();
      });
    }

    const pack = card.querySelector(".ph-pack");
    const search = card.querySelector(".ph-search");
    const btn = card.querySelector(".ph-search-btn");

    const runSearch = async () => {
      const packType = pack ? String(pack.value || "all") : "all";
      const q = search ? String(search.value || "").trim() : "";
      const box = card.querySelector(".ph-results");
      if (box) box.innerHTML = "<div style=\"opacity:0.7; padding:0.6rem;\">Loading‚Ä¶</div>";

      try {
        const items = await fetchDescriptorList(packType, q);
        renderPlaceholderResults(card, items);
      } catch (e) {
        if (box) box.innerHTML = "<div style=\"opacity:0.8; padding:0.6rem;\">Could not load descriptors.</div>";
      }
    };

    if (btn) btn.addEventListener("click", runSearch);

    let t = null;
    if (search) {
      search.addEventListener("input", () => {
        clearTimeout(t);
        t = setTimeout(runSearch, 250);
      });
    }

    if (pack) {
      pack.addEventListener("change", () => runSearch());
    }

    const clearBtn = card.querySelector(".ph-clear");
    if (clearBtn) {
      clearBtn.addEventListener("click", () => {
        const h = card.querySelector(".ph-desc-text");
        const ti = card.querySelector(".ph-text-input");
        if (h) h.value = "";
        if (ti) ti.value = "";
        setCardPreview(card, "");
        clientPreviewFinal();
      });
    }
  });
}

function attachFinalEditorHandlers() {
  const out = document.getElementById("finalOutput");
  if (!out) return;

  out.addEventListener("input", () => {
    setUserEditedFinal(true);
    syncFinalOverride();
  });

  const form = document.getElementById("useForm");
  if (form) {
    form.addEventListener("submit", () => {
      syncFinalOverride();
    });
  }
}

/* =========================
   Server-side copy
   ========================= */
async function copyToClipboardServer() {
  const form = document.getElementById("useForm");
  const out = document.getElementById("finalOutput");
  const pidEl = document.getElementById("promptId");
  if (!form || !pidEl) return;

  // Ensure we send the latest override value if active
  syncFinalOverride();

  const pid = parseInt(pidEl.value, 10);
  const fd = new FormData(form);

  try {
    const res = await fetch("/api/prompt/" + pid + "/render_final", { method: "POST", body: fd });
    const data = await res.json();
    if (!res.ok) throw new Error(data && data.error ? data.error : "render");

    const text = String(data.text || "");
    if (out && !isUserEditingFinal()) out.value = text;

    await navigator.clipboard.writeText(text);

    const feedback = document.getElementById("copyFeedback");
    if (feedback) {
      feedback.style.opacity = "1";
      setTimeout(() => feedback.style.opacity = "0", 1500);
    }

    // Best-effort usage history (existing behaviour)
    try {
      if (pid) {
        fetch("/api/prompt/" + pid + "/usage", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ content: text })
        });
      }
    } catch (e) {}

  } catch (e) {
    // Fallback: copy whatever is currently in the editor
    if (out) {
      out.select();
      out.setSelectionRange(0, 999999);
      await navigator.clipboard.writeText(out.value);
    }
  }
}

/* =========================
   Existing descriptor panel logic (mostly unchanged)
   ========================= */

const DESC_PREFERRED_ORDER = ["character","creature","environment","scene","action","prop","lighting","style","camera","clothing","pose","mood","material","vehicle","fx","other"];
let _descriptorTypes = [];
let _descTypesLoaded = false;
let _descScopeUiMode = "all";

function setDescriptorScope(mode) {
  _descScopeUiMode = (mode === "relevant") ? "relevant" : "all";

  const relevantBtn = document.getElementById("scopeRelevantBtn");
  const allBtn = document.getElementById("scopeAllBtn");
  if (relevantBtn) relevantBtn.style.opacity = (_descScopeUiMode === "relevant") ? "1" : "0.65";
  if (allBtn) allBtn.style.opacity = (_descScopeUiMode === "all") ? "1" : "0.65";

  const hint = document.getElementById("descriptorScopeHint");
  if (_descScopeUiMode === "relevant") {
    if (hint) hint.textContent = "(quick filters)";
  } else {
    if (hint) hint.textContent = "(all types)";
  }

  renderRelevantChips();
}

async function loadDescriptorTypesOnce() {
  if (_descTypesLoaded) return _descriptorTypes;

  try {
    const res = await fetch("/api/descriptors/types", { headers: { "Accept": "application/json" } });
    if (!res.ok) throw new Error("types");
    const types = await res.json();
    _descriptorTypes = Array.isArray(types) ? types.filter(Boolean).map(t => String(t)) : [];
  } catch (e) {
    _descriptorTypes = [];
  }

  const fallback = ["generic", "character", "creature", "environment", "scene", "action", "prop", "style", "lighting", "vehicle", "other"];
  const set = new Set(_descriptorTypes.map(t => t.trim()).filter(Boolean));
  fallback.forEach(t => set.add(t));

  _descriptorTypes = Array.from(set).sort((a, b) => a.localeCompare(b));
  _descTypesLoaded = true;
  return _descriptorTypes;
}

function getQuickChipTypes() {
  const types = _descriptorTypes.slice();
  const lower = new Set(types.map(t => String(t).toLowerCase()));
  const ordered = [];

  DESC_PREFERRED_ORDER.forEach(t => {
    if (lower.has(t)) ordered.push(t);
  });

  const extras = types
    .map(t => String(t).toLowerCase())
    .filter(t => !ordered.includes(t) && t !== "generic" && t !== "other")
    .slice(0, 8);

  return (_descScopeUiMode === "relevant") ? ordered.concat(extras) : types.map(t => String(t).toLowerCase());
}

function renderRelevantChips() {
  const wrap = document.getElementById("relevantChips");
  if (!wrap) return;

  wrap.innerHTML = "";

  const types = getQuickChipTypes();
  if (!types.length) return;

  const label = document.createElement("span");
  label.textContent = "Quick filters:";
  label.style.opacity = "0.7";
  label.style.fontSize = "0.9em";
  label.style.marginRight = "0.25rem";
  wrap.appendChild(label);

  const seen = new Set();
  types.forEach(t => {
    const key = String(t).toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "btn-secondary";
    btn.textContent = key;
    btn.style.padding = "0.25rem 0.6rem";
    btn.style.fontSize = "0.9em";
    btn.onclick = () => {
      const sel = document.getElementById("descriptorPackSelect");
      if (sel) sel.value = key;
      refreshDescriptors(true);
    };
    wrap.appendChild(btn);
  });
}

function populatePackDropdown() {
  const select = document.getElementById("descriptorPackSelect");
  if (!select) return;

  const current = select.value;

  select.innerHTML = "<option value=\"all\">(All packs)</option>";

  const types = _descriptorTypes.slice().map(t => String(t).toLowerCase());
  const seen = new Set();
  types.forEach(t => {
    const key = t.trim();
    if (!key || seen.has(key)) return;
    seen.add(key);

    const opt = document.createElement("option");
    opt.value = key;
    opt.textContent = key;
    select.appendChild(opt);
  });

  if ([...select.options].some(o => o.value === current)) {
    select.value = current;
  } else {
    select.value = "all";
  }
}

function buildDescriptorListUrl() {
  const q = (document.getElementById("descriptorSearch")?.value || "").trim();
  const packSel = (document.getElementById("descriptorPackSelect")?.value || "all").trim();

  const params = new URLSearchParams();
  if (q) params.set("q", q);
  if (packSel && packSel !== "all") params.set("pack_type", packSel);

  return "/api/descriptors/list?" + params.toString();
}

function setDescriptorStatus(msg) {
  const el = document.getElementById("descriptorStatus");
  if (el) el.textContent = msg || "";
}

function flashInserted() {
  const feedback = document.getElementById("descriptorInsertFeedback");
  if (!feedback) return;
  feedback.style.opacity = "1";
  setTimeout(() => feedback.style.opacity = "0", 1500);
}

function insertTextAtCursor(text) {
  const ta = document.getElementById("finalOutput");
  if (!ta) return;

  const start = ta.selectionStart;
  const end = ta.selectionEnd;

  const before = ta.value.substring(0, start);
  const after = ta.value.substring(end);

  const needsSpaceBefore = before.length && !/\s$/.test(before);
  const needsSpaceAfter = after.length && !/^\s/.test(after);

  const insert = (needsSpaceBefore ? " " : "") + text + (needsSpaceAfter ? " " : "");
  ta.value = before + insert + after;

  const cursorPos = (before + (needsSpaceBefore ? " " : "") + text + (needsSpaceAfter ? " " : "")).length;
  ta.focus();
  ta.setSelectionRange(cursorPos, cursorPos);

  setUserEditedFinal(true);
  syncFinalOverride();
  flashInserted();
}

function insertDescriptorText(d) {
  const text = (d && (d.rendered_text || d.description) ? (d.rendered_text || d.description) : "").trim();
  if (!text) return;
  insertTextAtCursor(text);
}

function insertDescriptorToken(id) {
  const token = String.fromCharCode(123,123) + "descriptor:" + id + String.fromCharCode(125,125);
  insertTextAtCursor(token);
}

function renderDescriptorResults(items) {
  const box = document.getElementById("descriptorResults");
  if (!box) return;

  box.innerHTML = "";

  if (!items || !items.length) {
    const empty = document.createElement("div");
    empty.style.opacity = "0.7";
    empty.style.padding = "0.75rem";
    empty.textContent = "No descriptors found.";
    box.appendChild(empty);
    return;
  }

  items.forEach(d => {
    const row = document.createElement("div");
    row.style.border = "1px solid #333";
    row.style.borderRadius = "8px";
    row.style.padding = "0.6rem 0.75rem";
    row.style.margin = "0.5rem";
    row.style.background = "#0e0e0e";
    row.style.cursor = "pointer";

    const title = document.createElement("div");
    title.textContent = d.title || "(Untitled)";
    title.style.fontWeight = "bold";
    title.style.marginBottom = "0.25rem";

    const meta = document.createElement("div");
    meta.style.opacity = "0.7";
    meta.style.fontSize = "0.85em";
    meta.textContent = (d.pack_type || "unknown") + " ‚Ä¢ ID " + d.id;

    const preview = document.createElement("div");
    preview.style.marginTop = "0.4rem";
    preview.style.opacity = "0.9";
    preview.style.fontSize = "0.95em";
    preview.style.whiteSpace = "pre-wrap";
    preview.style.lineHeight = "1.35";
    preview.textContent = (d.rendered_text || d.description || "").slice(0, 220);

    row.appendChild(title);
    row.appendChild(meta);
    if (preview.textContent) row.appendChild(preview);

    row.onclick = () => insertDescriptorText(d);

    const actions = document.createElement("div");
    actions.style.marginTop = "0.55rem";
    actions.style.display = "flex";
    actions.style.gap = "0.5rem";
    actions.style.flexWrap = "wrap";

    const btnText = document.createElement("button");
    btnText.type = "button";
    btnText.className = "btn-secondary";
    btnText.textContent = "Insert text";
    btnText.style.padding = "0.25rem 0.6rem";
    btnText.style.fontSize = "0.9em";
    btnText.onclick = (e) => { e.stopPropagation(); insertDescriptorText(d); };

    const btnToken = document.createElement("button");
    btnToken.type = "button";
    btnToken.className = "btn-secondary";
    btnToken.textContent = "Token";
    btnToken.style.padding = "0.25rem 0.6rem";
    btnToken.style.fontSize = "0.9em";
    btnToken.title = "Insert as a descriptor reference token";
    btnToken.onclick = (e) => { e.stopPropagation(); insertDescriptorToken(d.id); };

    actions.appendChild(btnText);
    actions.appendChild(btnToken);
    row.appendChild(actions);

    box.appendChild(row);
  });
}

async function fetchDescriptors(url) {
  const res = await fetch(url, { method: "GET", headers: { "Accept": "application/json" } });
  if (!res.ok) throw new Error("list");
  return await res.json();
}

async function refreshDescriptors() {
  const q = (document.getElementById("descriptorSearch")?.value || "").trim();
  const packSel = (document.getElementById("descriptorPackSelect")?.value || "all").trim();

  setDescriptorStatus("Loading‚Ä¶");

  try {
    const url = buildDescriptorListUrl();
    const data = await fetchDescriptors(url);
    const items = Array.isArray(data) ? data : [];

    if (packSel !== "all" && _descriptorTypes.length) {
      const lower = new Set(_descriptorTypes.map(t => String(t).toLowerCase()));
      if (!lower.has(packSel.toLowerCase())) {
        const sel = document.getElementById("descriptorPackSelect");
        if (sel) sel.value = "all";
      }
    }

    setDescriptorStatus(items.length ? (items.length + " found") : (q ? "No results" : "No descriptors"));
    renderDescriptorResults(items);
  } catch (e) {
    setDescriptorStatus("Failed to load");
    const box = document.getElementById("descriptorResults");
    if (box) {
      box.innerHTML = "<div style=\"opacity:0.8; padding:0.75rem;\">Could not load descriptors. Check that <code>/api/descriptors/list</code> is available.</div>";
    }
  }
}

let _descTimer = null;
function debouncedRefreshDescriptors() {
  clearTimeout(_descTimer);
  _descTimer = setTimeout(() => refreshDescriptors(), 250);
}

(async function initUsePrompt() {
  // Placeholder picker packs
  const types = await loadDescriptorTypes();
  populateAllPlaceholderPackSelects(types);
  attachPlaceholderHandlers();

  // Final editor handlers
  attachFinalEditorHandlers();

  // Initial previews
  getPlaceholderCards().forEach(card => setCardPreview(card, ""));
  clientPreviewFinal();

  // Descriptor panel (global)
  await loadDescriptorTypesOnce();
  populatePackDropdown();
  setDescriptorScope("all");
  renderRelevantChips();
  refreshDescriptors();
})();

  // Template preview: jump to next occurrence of a placeholder when clicking its card
  // Ensure placeholder mode toggle always works (event delegation + initial sync)
(function () {
  function applyModeForCard(card) {
    if (!card) return;

    const modeEl = card.querySelector(".ph-mode");
    const mode = modeEl ? String(modeEl.value || "text") : "text";

    const d = card.querySelector(".ph-descriptor");
    const t = card.querySelector(".ph-text");

    if (d) d.style.display = (mode === "descriptor") ? "block" : "none";
    if (t) t.style.display = (mode === "text") ? "block" : "none";
  }

  // Initial sync (in case anything loads before handlers attach)
  document.querySelectorAll(".ph-card").forEach(applyModeForCard);

  // Delegated change handler (robust even if other JS runs before/after)
  document.addEventListener("change", function (ev) {
    const sel = ev.target && ev.target.closest ? ev.target.closest(".ph-mode") : null;
    if (!sel) return;

    const card = sel.closest(".ph-card");
    applyModeForCard(card);

    // Keep preview in sync if available
    try {
      if (typeof clientPreviewFinal === "function") clientPreviewFinal();
    } catch (e) {}
  });
})();

// Template preview: jump to next occurrence of a placeholder when clicking its card
(function () {
  const templateBox = document.getElementById("templatePreview");
  if (!templateBox) return;

  function selectNextOccurrence(token) {
    const hay = templateBox.value || "";
    if (!hay || !token) return;

    const startFrom = (templateBox.selectionEnd || 0);
    let idx = hay.indexOf(token, startFrom);
    if (idx === -1) idx = hay.indexOf(token, 0);
    if (idx === -1) return;

    templateBox.focus();
    templateBox.setSelectionRange(idx, idx + token.length);

    const before = hay.slice(0, idx);
    const line = before.split("\n").length - 1;
    const approxLineHeight = 18;
    templateBox.scrollTop = Math.max(0, (line - 2) * approxLineHeight);
  }

  document.addEventListener("click", function (ev) {
    const t = ev.target;

    // If user clicked inside an interactive control within the variable card, do NOT jump.
    if (t && t.closest && t.closest("input, select, textarea, button, a, .ph-results")) {
      return;
    }

    const card = t && t.closest ? t.closest(".ph-card") : null;
    if (!card) return;

    const disp = card.getAttribute("data-ph-display") || "";
    if (!disp) return;

    const token = "[[" + disp + "]]";
    selectNextOccurrence(token);
  });
})();

</script>

{% endblock %}
